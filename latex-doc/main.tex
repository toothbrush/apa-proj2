\documentclass[a4paper]{article}

\author{Paul van der Walt (3120805)} \date{\today} \title{Implementation notes
for Type Reconstruction}

\begin{document}

\maketitle \tableofcontents

\section{Introduction}

This project aims to make a type inferencer. The input is a Hindley-Milner-like
language with implicit typing, and we want to infer this type information and
annotate the terms explicitly. This solution is an implementation of
Algorithm~W. 

\section{Approach}

This solution was implemented in the UUAG (University of Utrecht Attribute
Grammar) system, which provides a natural syntax-driven way of computing
information using trees. Since the untyped language is parsed into a tree-like
expression, this makes the implementation clear and clutter-free.

A number of attributes are declared on the input tree, along with a definition of
how to compute them given different types of nodes. The attributes which were
chosen in this implementation are:

\begin{itemize} 
    \item \texttt{counter}, which uses the AG builtin method for
        generating consecutive unique identifiers per node, which we use to dish
        out free unused type variables.  
    \item \texttt{typeEnvironment}, the
        environment which maps type variables to signatures. We pass this down
        and add bindings to it when encountering \emph{let} or \emph{lambda}
        bindings.  
    \item \texttt{inferredType}, the synthesized attribute which
        contains the type of a term as dictated by Algorithm~W.  
    \item
        \texttt{substitution}, finally, which gives the substitution of type
        variables for types generated by the unification algorithm.
\end{itemize}

Helper-attributes are: 

\begin{itemize} 
    \item \texttt{annotated}, which returns the type-annotated term
        in System F according to the input-term in HM, using the other
        attributes combined. 
\end{itemize}

\section{Design}

The specification used for Algorithm~W is the one from the Compiler Construction
course slides, accompanying the lecture on type systems. Here, a description is
given of the type inferencing algorithm, in a declarative style (perfect for
translating to AG, which is essentially a set of pattern-matchings on the
expression tree), along with helper functions like those for unification,
substitution of types, instantiation and generalisation, etc. which are directly translated into the AG (file
\texttt{CCO/HM/AG/Infer.ag}) and the \emph{CCO.Types} module.

Since the results of algorithm~W, a type and a substitution to be applied to the
final term, can be computed separately, we create an attribute for each, leading
to clearer code. The type environment (which is just a mapping from variable
names to types in this implementation) is modified separately, while in the
slides this is a third effect of the function \emph{W}. This is therefore
translated into an inherited attribute which is only modified in the cases of a
variable or a let-construction. 


\section{Implemented}

The implementation of algorithm~W in this submission is reasonably naive, i.e.
no optimisations or clever tricks have been applied, such as the assignment
suggests. This leads to, for example, more abstractions (foreach constructions)
than necessary. 

The most difficult part was figuring out how to combine the original term (of
type \texttt{HM.Tm}) and the inferred type information into a final System F
term. This was done in the attribute \texttt{annotated}, once the idea had
formed that it was necessary to instantiate when a variable was encountered, and
to generalise when a let was encountered. With this insight, all that was needed
was some fiddling with the coercions to get the correct term as output. 

The idea behind the coercions (auxiliary output of the functions
\emph{instantiate} and \emph{generalise}) are that when generalising or
instantiating the eventual (System F) terms should be wrapped in type
applications or type lambdas, which the coercion functions do, so we aren't left
with free type variables. 

\section{Example programs}

\begin{itemize}
    \item \texttt{app.hm} An illustration of the function application in action. 
    \item \texttt{assignment.hm} The example program from the assignment, with
        the correct output. 
    \item \texttt{identity.hm} The simplest possible program, the identity
        function. 
    \item \texttt{inf.hm} Gives a type error, correctly (the program, $\lambda
        x.
        \lambda y . (y x) (x y)$ isn't typable and leads to a so-called
        \emph{occurs check\footnote{Meaning that the unification algorithm would
        have to introduce an infinite type to succeed.}}).
    \item \textit{singleton.hm} Simply illustrates a variable which is out of
        scope. 
\end{itemize}

\end{document}
