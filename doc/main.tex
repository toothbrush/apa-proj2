
%outline:

% a type system
% specification and an explanation of both the type system, a run through of one
% or two examples and an architectural description of the implementation.
% Features and limitations should be prominently displayed in your documentation. 

\documentclass[a4paper]{article}

\usepackage{semantic}
\usepackage{dsfont}
\usepackage{a4wide}
\usepackage{array}
\usepackage{bussproofs}
\usepackage{latexsym}


% things for the semantic package
\reservestyle{\command}{\textbf}
\command{let,in,:,case,of,if,then,else}
\mathlig{-->}{\longrightarrow}
\newcommand{\tyrel}{\sqsubseteq}
% end semantic

\author{Jurri\"en Stutterheim (3555003)\and Ruben de Gooijer (3508617) \and Paul van der Walt (3120805)}
\date{\today} 
\title{Implementation notes for Type and Effect Systems}

\begin{document}

\maketitle \tableofcontents

\section{Introduction}

This project aims to implement a tool which can do a control-flow analysis on a lambda-calculus language with support for
data structures. The focus is on lists%and pairs
, for now.
%todo: more. 

\section{Design}

Here we will detail the design of the language, for example which features it
supports. In Tables \ref{tab:elems} and \ref{tab:grammar} one can see the
grammar of the language. It is based on Haskell (in fact we use the Haskell
source extensions parser), but of course only a subset is supported. 

We include support for% pairs and
 lists, as well as a case statement in which one
can pattern-match on these data structures. There is not yet support for general
data structures.

\subsection{A simple functional language}

%todo: copied from slides, may need adjustment.

The basic elements of the language can be found in Table \ref{tab:elems}. The
language includes natural number constants, variables, and operators. Program
points are introduced whenever a lambda-expression is encountered.
\begin{table}
    \centering
    \begin{tabular}{rcll}
        $n$ &           $\in$ & \textbf{Num = $\mathds{N}$}& numerals \\
        $f,x$ &         $\in$ & \textbf{Var}               & variables \\
        $\oplus$ &      $\in$ & \textbf{Op}                & binary operators \\
        $\pi$ &         $\in$ & \textbf{Pnt}               & program points  \\
        $t$ &           $\in$ & \textbf{Tm}                & terms \\
    \end{tabular}
    \caption{Basic elements}
    \label{tab:elems}
\end{table}

In Table \ref{tab:grammar} one can see what constructs are valid in our subset
of Haskell, since only a very limited subset is supported. Note that recursion
is only supported inside \textbf{let}s. 

\begin{table}
    \centering
    \begin{tabular}{lcl}
        \hline
        $t$    & ::= & $n\: |\: \textbf{ false }\: |\: \textbf{ true }\: |\: x\: |\: \lambda_\pi x.t_1 \:$ \\
               & $|$ & $t_1 t_2 \:|\: \textbf{ if } t_1 \textbf{ then } t_2 \textbf{ else } t_3 \:|\:  \textbf{ let } x = t_1 \textbf{ in } t_2$\\
               & $|$ & $\mu f.\textbf{ let } x = t_1 \textbf{ in } t_2$\\
               & $|$ & $t_1 \oplus t_2 \:|\: [\,]_\pi \:|\:t_1\<:>_\pi t_2   $\\%     \: | \: (t_1,t_2)_\pi $ \\ 
               & $|$ & $ \textbf{case } e_0 \textbf{ of } alts $ \\
        $alts$ & ::= & $alt_0; alt_1$ \\
        $alt$  & ::= & $patt \rightarrow t$ \\
        $patt$ & ::= & $x \:|\: \textbf{True} \:|\: \textbf{False}            $\\%                \:|\: (patt, patt)$ \\
               & $|$ & $(x: patt)  \:|\: [\,]$\\
        \hline
    \end{tabular}
    \caption{Abstract syntax. $t$ is a term.}
    \label{tab:grammar}
\end{table}

\subsection{Type System}

Here we will detail the type system which has been implemented in this project.
It consists of a polymorphic type system, with the important addition of
annotations. We use annotations and constraints to be able to do a control-flow
analysis, eventually telling us which functions one may expect to be used where. 

Our type system has variables, arrows, and type environments, as well as
annotations, which is what makes it different from a normal polymorphic type
system. Table \ref{tab:typingelems} and \ref{tab:typing} show the elements of
the type system. 

\begin{table}
    \centering
    \begin{tabular}{rcll}
        $\varphi$ &               $\in$ & \textbf{Ann}                   & annotations \\ 
        $\widehat{\tau}$&         $\in$ & $\widehat{\textbf{Ty}      } $ & annotated types \\
        $\widehat{\sigma} $&      $\in$ & $\widehat{\textbf{TyScheme}} $ & annotated type schemes\\
        $\widehat{\Gamma}$&       $\in$ & $\widehat{\textbf{TyEnv}   } $ & annotated type environments  \\
    \end{tabular}
    \caption{Typing elements, annotated types}
    \label{tab:typingelems}
\end{table}
\begin{table}
    \centering
    \begin{tabular}{lcl}
        $ \varphi$         & ::= & $ \emptyset \:|\: \{\pi\} \:|\: \varphi_1 \cup \varphi_2 $ \\
        $\widehat{\tau}$   & ::= & $\alpha \:|\: Nat \: | \: Bool \: | \: $ \\
        & $|$ & $\widehat{\tau}_1^{\varphi_1}
                           \stackrel{\varphi}{\rightarrow} 
                           \widehat{\tau}_2^{\varphi_2} $ \\
                           & $|$ & $ % \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 \:|\: 
                           [\widehat{\tau}]^\varphi   $ \\ 
        $\widehat{\sigma}$ & ::= & $\widehat{\tau} \:|\: \forall \alpha. \widehat{\sigma}_1 $ \\ 
        $\widehat{\Gamma}$ & ::= & $[\,] \:|\: \widehat{\Gamma}_1[x \mapsto \widehat{\sigma}] $ \\
    \end{tabular}
    \caption{Typing}
    \label{tab:typing}
\end{table}

Next a list of typing judgements will be given. This constitutes the final type
system. %See weijers fig 5.3 for a reference. 

These rules are formulated in a syntax-directed fashion. 

\begin{table}
    \centering
    \begin{tabular}{ll}
%TODO FIXME
        \hline
        $ [$\emph{t-cons}$] $& \inference{
        {\Gamma},C |- e_1 : \tau^{\varphi_1}
        & \Gamma,C |- e_2 : ([\tau^{\varphi_2}]^{\varphi_3}
        & C |- \varphi_2 \tyrel \varphi_1
        & C |- \varphi_3 \tyrel \varphi
        }
        {
        {\Gamma},C |- e_1 \<:> e_2  : ([\tau^{\varphi_1}])^{\varphi}
        } \\
~&~\\
        $ [$\emph{t-var}$] $& \inference{
        {\Gamma}(x) = ({\sigma},\varphi)
        & C |- \varphi \tyrel \varphi_1 
        & inst(\sigma) = C' => \tau
        }
        {
        {\Gamma},C\cup C' |- x  : {\tau^{\varphi_1}}
        } \\
~&~\\
        $ [$\emph{t-app}$] $& \inference{
        \Gamma,C |- e_1 : \tau_2^{\varphi_2} ->^{\varphi} \tau_0^{\varphi_0}
        & \Gamma,C|- e_2 : \tau_2^{\varphi_3}
        & C|- \varphi_3 \tyrel \varphi_2
        & C|- \varphi   \tyrel \varphi_4
        & C|- \varphi_0 \tyrel \varphi_4
        }
        {
        \Gamma, C |- e_1 e_2 : \tau_0^{\varphi_4}
        } \\
~&~\\
        $ [$\emph{t-if}$] $& \inference{
        \Gamma, C |- e_0 : Bool^{\varphi_0}
        & \Gamma, C |- e_1 : \tau^{\varphi_1}
        & \Gamma, C |- e_2 : \tau^{\varphi_2}
        & C |- \varphi_0 \tyrel \varphi
        & C |- \varphi_1 \tyrel \varphi
        & C |- \varphi_2 \tyrel \varphi
        }
        {
        \Gamma,C|- \<if>\: e_0\: \<then>\: e_1\: \<else>\: e_2 : \tau^{\varphi}
        } \\
~&~\\
        $ [$\emph{t-bin-op}$] $& \inference{ % what about all the annotated simple vars?
        \Gamma, C |- e_1 : \tau_{1\oplus}^{\varphi_1}
        & \Gamma, C |- e_2 : \tau_{2\oplus}^{\varphi_2}
        & C |- \varphi_1 \tyrel \varphi
        & C |- \varphi_2 \tyrel \varphi
        }
        {
        \Gamma, C|- e_1 \oplus e_2 : \tau_{\oplus}^\varphi
        } \\
~&~\\
% todo do we need rules for case statements involving head and tail of lists??
        $ [$\emph{t-let}$] $& \inference{
        \Gamma, C' |- e_1 : \tau_1^{\varphi_1}
        & (C'',\sigma) = gen(C', \tau_1)
        & \Gamma[x \mapsto (\sigma, \varphi_1)],C\cup C'' |- e_2 : \tau_2^{\varphi_2}
        & C\cup C'' |- \varphi_2 \tyrel \varphi_3
        }
        {
        \Gamma,C\cup C'' |- \<let>\: x = e_1\: \<in>\: e_2 : \tau_2^{\varphi_3}
        } \\
~&~\\
%         $ [$\emph{t-app}$] $& \inference{
% ~ 
%         }
%         {
% ~ 
%         } \\
% ~&~\\
%TODO FIXME 
        \hline
    \end{tabular}
    \caption{Typing judgements}
    \label{tab:typing-rules}
\end{table}

\subsection{Example Derivation}

\begin{prooftree}
\small
\AxiomC{$asdf$}
\RightLabel{\scriptsize{id}}
\UnaryInfC{$A a \vdash A a$}
  \AxiomC{$instance A a \Rightarrow A (Maybe a)$}
  \RightLabel{\scriptsize{inst}}
\BinaryInfC{$A a oplus A Maybe( a)$}
\RightLabel{\scriptsize{closure}}
\UnaryInfC{$A (Maybe a) oplus A (Maybe (Maybe a))$}
  \AxiomC{$$}
  \RightLabel{\scriptsize{id}} 
  \UnaryInfC{$A a oplus A a$}
    \AxiomC{$instance A a \Rightarrow A (Maybe a)$} 
  \RightLabel{\scriptsize{inst}}
  \BinaryInfC{$A a oplus A (Maybe a)$}
\RightLabel{\scriptsize{trans}}
\BinaryInfC{$A  a oplus A (Maybe (Maybe a))$}
\RightLabel{\scriptsize{closure}}
\UnaryInfC{$A Int oplus A (Maybe (Maybe Int))$}
  \AxiomC{$asdf$}
  \RightLabel{\scriptsize{id}}
  \UnaryInfC{$B a oplus B a$}
    \AxiomC{$class (A a) \Rightarrow B a$}
  \BinaryInfC{$B a oplus A a$}
  \RightLabel{\scriptsize{closure}}
  \UnaryInfC{$B Int oplus A Int$}
\RightLabel{\scriptsize{trans}}
\BinaryInfC{$B Int oplus A (Maybe (Maybe Int))$}
\end{prooftree}


\subsection{Natural semantics}

In this section, Table \ref{tab:natural-semantics}, we define how terms are
evaluated. This is also known as big-step semantics. Notice the addition of
\textbf{case}-statements for data structure use. See Table 5.4 in \cite{nnh}
for reference. Our listing isn't complete, only the additions with respect to the 
aforementioned table are shown. 

\begin{table}
    \centering
    \begin{tabular}{ll}
        \hline
        $ [$\emph{ns-con}$] $& $ |- c --> c$ \\ ~&~\\
        $ [$\emph{ns-fn}$]  $& $ |- \lambda_\pi x.t_1 --> \lambda_\pi x.t_1$ \\ ~&~\\
%        $ [$\emph{ns-fn$_{rec}$}$]  $& $ |- \mu f.\lambda_\pi x.t_1 --> \lambda_\pi x.(t_1[f \mapsto \lambda_\pi x.t_1 ])$ \\ ~&~\\
%         $ [$\emph{ns-case$_{pair}$}$] $& \inference{|- e_0 --> (x_1,x_2) & |- x_1 --> v_1 & |- x_2 --> v_2}
% {|- (\<case>\: e_0\: \<of>\: (x_1,x_2) -> e_1) --> e_1[x_1\mapsto v_1, x_2 \mapsto v_2]} \\ ~&~\\
        $ [$\emph{ns-case$_{list1}$}$] $& \inference{|- e_0 --> [] }
{|- (\<case>\: e_0\: \<of>\: [] -> e_1; (x\<:>xs) -> e_2) --> e_1} \\ ~&~\\
        $ [$\emph{ns-case$_{list2}$}$] $& \inference{|- e_0 --> (x\<:>xs) & x --> v & xs --> vs }
{|- (\<case>\: e_0\: \<of>\: [] -> e_1; (x\<:>xs) -> e_2) --> e_2[x\mapsto v, xs \mapsto vs]} \\ ~&~\\


        \hline
    \end{tabular}
    \caption{Natural semantics for the language}
    \label{tab:natural-semantics}
\end{table}

\subsection{Control Flow Analysis}

We have the usual set of rules including, for example,  \emph{cfa-var} or
\emph{cfa-let}, which has been extended to support lists, see \emph{cfa-nil}
and \emph{cfa-cons}, the rules specifying list-typing, Table
\ref{tab:cfa-rules}. CFA judgements look like {$\widehat{\Gamma}\:\vdash_{CFA}
t : \widehat{\sigma}$}, meaning that some term $t$ has inferred type
$\widehat{\sigma}$ in context $\widehat{\Gamma}$. See Table 5.2 in \cite{nnh}
for reference. 


\begin{table}
    \centering
    \begin{tabular}{ll}
        \hline
        $ [$\emph{cfa-var}$] $& \inference{\widehat{\Gamma}(x) = \widehat{\sigma}}
{\widehat{\Gamma} |-_{CFA} x  : \widehat{\sigma}} \\
~&~\\
$[$\emph{cfa-let}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma}_1 
& \widehat{\Gamma}[x \mapsto \widehat{\sigma}_1] |-_{CFA} t_2 : \widehat{\tau}}
{\widehat{\Gamma} |-_{CFA}\: \<let>\: x = t_1\: \<in>\: t_2 : \widehat{\tau}} \\
~&~\\
$[$\emph{cfa-nil}$] $& 
\inference{}
{\widehat{\Gamma} |-_{CFA} [\,] : [\widehat{\sigma}]} \\
~&~\\
$[$\emph{cfa-cons}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma} 
 \widehat{\Gamma}|-_{CFA} t_2 : [\widehat{\sigma}]}
{\widehat{\Gamma} |-_{CFA} t_1 \<:> t_2 :  [\widehat{\sigma}]} \\
~&~\\
% $[$\emph{cfa-pair}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1 : \widehat{\tau}_1 &  \widehat{\Gamma} |-_{CFA} t_2 : \widehat{\tau}_2   } 
% {\widehat{\Gamma} |-_{CFA} (t_1,t_2) : \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 } \\
% ~&~\\
% $[$\emph{cfa-case-pair}$] $& \inference{\widehat{\Gamma} |-_{CFA} e_0 : \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 
% &  \widehat{\Gamma} |-_{CFA} e_1 : \widehat{\tau}   } 
% {\widehat{\Gamma} |-_{CFA} \:\<case>\: e_0\: \<of>\: (x_1,x_2) \Rightarrow e_1 : \widehat{\tau} } \\
% ~&~\\
$[$\emph{cfa-case-nil}$] $& \inference{\widehat{\Gamma} |-_{CFA} e_0 : [\widehat{\tau}_1] &  \widehat{\Gamma} |-_{CFA} e_1 : \widehat{\tau}   } 
{\widehat{\Gamma} |-_{CFA} \:\<case>\: e_0\: \<of>\: [] \Rightarrow e_1 : \widehat{\tau} }, if $e_0$ empty\\
~&~\\
$[$\emph{cfa-case-cons}$] $& \inference{\widehat{\Gamma} |-_{CFA} e_0 : [\widehat{\tau}_1] &  \widehat{\Gamma} |-_{CFA} e_1 : \widehat{\tau}   } 
{\widehat{\Gamma} |-_{CFA} \:\<case>\: e_0\: \<of>\: (x\<:>xs) \Rightarrow e_1 : \widehat{\tau} }, if $e_0$ nonempty\\

        \hline
    \end{tabular}
    \caption{Control Flow Analysis rules. }
    \label{tab:cfa-rules}
\end{table}

\section{Approach}


\section{Implemented}

\section{Example programs}

Example programs can be found in the \texttt{examples/} directory of the distribution, 
and have an extension \texttt{.hm}. Feed the program the files via \emph{stdin}. Each file
includes comments which describe its expected analysis result, and possible peculiarities
it may have. Note the directory \texttt{ill-typed/}, in which the examples fail by design.
They include examples of infinite types, etc. 


\begin{thebibliography}{9}

\bibitem{nnh}
  {Flemming Nielson, Hanne Riis Nielson, Chris Hankin},
  \emph{Principles of Program Analysis},
  Springer, Berlin,
  2nd Edition,
  2005.

\end{thebibliography}

\end{document}
