\documentclass[a4paper]{article}

\usepackage{semantic}
\usepackage{dsfont}

% things for the semantic package
\reservestyle{\command}{\textbf}
\command{let,in,:}
% end semantic

\author{Jurri\"en Stutterheim\and Ruben de Gooijer \and Paul van der Walt} 
\date{\today} 
\title{Implementation notes for Type and Effect Systems}

\begin{document}

\maketitle \tableofcontents

\section{Introduction}

This project aims to implement a tool which can do a control-flow analysis on a lambda-calculus language with support for
data structures. 
%todo: more. 

\section{Design}

\subsection{A simple functional language}

%todo: copied from slides, may need adjustment.

\begin{table}
    \centering
    \begin{tabular}{rcll}
        $n$ &           $\in$ & \textbf{Num = $\mathds{N}$}& numerals \\
        $f,x$ &         $\in$ & \textbf{Var}               & variables \\
        $\oplus$ &      $\in$ & \textbf{Op}                & binary operators \\
        $\pi$ &         $\in$ & \textbf{Pnt}               & program points  \\
        $t$ &           $\in$ & \textbf{Tm}                & terms \\
    \end{tabular}
    \caption{Basic elements}
    \label{tab:elems}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{lcl}
        $t$ & ::= & $n\: |\: \textbf{ false }\: |\: \textbf{ true }\: |\: x\: |\: \lambda_\pi x.t_1\: |\: \mu f.\lambda_\pi x . t_1$ \\
            & $|$ & $t_1 t_2 \:|\: \textbf{ if } t_1 \textbf{ then } t_2 \textbf{ else } t_3 \:|\: \textbf{ let } x = t_1 \textbf{ in } t_2$\\
            & $|$ & $t_1 \oplus t_2 \:|\: [\,]\:|\:t_1:t_2 $\\
    \end{tabular}
    \caption{Grammar}
    \label{tab:grammar}
\end{table}

\subsection{Typing}

\begin{table}
    \centering
    \begin{tabular}{rcll}
        $\alpha$ &      $\in$ & \textbf{TyVar}    & type variables  \\
        $\tau$&         $\in$ & \textbf{Ty}       & types \\
        $\sigma $&      $\in$ & \textbf{TyScheme} & type schemes\\
        $\Gamma$&       $\in$ & \textbf{TyEnv}    & type environments  \\
    \end{tabular}
    \caption{Typing elements}
    \label{tab:typingelems}
\end{table}
\begin{table}
    \centering
    \begin{tabular}{lcl}
        $\tau$   & ::= & $\alpha \:|\: Nat \: | \: Bool \: | \: \tau_1 \rightarrow \tau_2 $ \\ 
        $\sigma$ & ::= & $\tau \:|\: \forall \alpha. \sigma_1 $ \\ 
        $\Gamma$ & ::= & $[\,] \:|\: \Gamma_1[x \mapsto \sigma] $ \\
    \end{tabular}
    \caption{Typing}
    \label{tab:typing}
\end{table}

\fbox{$\Gamma\:\vdash_{UL} t : \sigma$}

\subsection{Natural semantics}

We have the usual set of rules including, for example,  \emph{cfa-var} or \emph{cfa-let}, which has been extended to support lists, see \emph{cfa-nil} and \emph{cfa-cons}, the rules specifying list-typing. 

\inference[cfa-var]{\widehat{\Gamma}(x) = \widehat{\sigma}}
{\widehat{\Gamma} |-_{CFA} x  : \widehat{\sigma}}

\inference[cfa-let]{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma}_1 
& \widehat{\Gamma}[x \mapsto \widehat{\sigma}_1] |-_{CFA} t_2 : \widehat{\tau}}
{\widehat{\Gamma} |-_{CFA}\: \<let>\: x = t_1\: \<in>\: t_2 : \widehat{\tau}}


\inference[cfa-nil]{\widehat{\Gamma} |-_{CFA} t : \widehat{\sigma}}
{\widehat{\Gamma} |-_{CFA} t\<:>[\,] : [\widehat{\sigma}]}

\inference[cfa-cons]{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma} 
& \widehat{\Gamma}|-_{CFA} t_2 : [\widehat{\sigma}]}
{\widehat{\Gamma} |-_{CFA} t_1 \<:> t_2 :  [\widehat{\sigma}]}

\section{Approach}


\section{Implemented}

\section{Example programs}

%todo: this probably needs fixing. 
\begin{itemize}
    \item \texttt{app.hm} An illustration of the function application in action. 
    \item \texttt{assignment.hm} The example program from the assignment, with
        the correct output. 
    \item \texttt{identity.hm} The simplest possible program, the identity
        function. 
    \item \texttt{inf.hm} Gives a type error, correctly (the program, $\lambda
        x.
        \lambda y . (y x) (x y)$ isn't typable and leads to a so-called
        \emph{occurs check\footnote{Meaning that the unification algorithm would
        have to introduce an infinite type to succeed.}}).
    \item \textit{singleton.hm} Simply illustrates a variable which is out of
        scope. 
\end{itemize}

\end{document}
