\documentclass[a4paper]{article}

\usepackage{semantic}
\usepackage{dsfont}

% things for the semantic package
\reservestyle{\command}{\textbf}
\command{let,in,:}
% end semantic

\author{Jurri\"en Stutterheim\and Ruben de Gooijer \and Paul van der Walt} 
\date{\today} 
\title{Implementation notes for Type and Effect Systems}

\begin{document}

\maketitle \tableofcontents

\section{Introduction}

This project aims to implement a tool which can do a control-flow analysis on a lambda-calculus language with support for
data structures. The focus is on lists and pairs, for now.
%todo: more. 

\section{Design}

\subsection{A simple functional language}

%todo: copied from slides, may need adjustment.

\begin{table}
    \centering
    \begin{tabular}{rcll}
        $n$ &           $\in$ & \textbf{Num = $\mathds{N}$}& numerals \\
        $f,x$ &         $\in$ & \textbf{Var}               & variables \\
        $\oplus$ &      $\in$ & \textbf{Op}                & binary operators \\
        $\pi$ &         $\in$ & \textbf{Pnt}               & program points  \\
        $t$ &           $\in$ & \textbf{Tm}                & terms \\
    \end{tabular}
    \caption{Basic elements}
    \label{tab:elems}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{lcl}
        $t$     & ::= & $n\: |\: \textbf{ false }\: |\: \textbf{ true }\: |\: x\: |\: \lambda_\pi x.t_1\: |\: \mu f.\lambda_\pi x . t_1$ \\
                & $|$ & $t_1 t_2 \:|\: \textbf{ if } t_1 \textbf{ then } t_2 \textbf{ else } t_3 \:|\: \textbf{ let } x = t_1 \textbf{ in } t_2$\\
                & $|$ & $t_1 \oplus t_2 \:|\: [\,]_\pi \:|\:t_1\<:>_\pi t_2 \: | \: (t_1,t_2)_\pi $ \\ 
                & $|$ & $ \texttt{case } e_0 \texttt{ of } alts $ \\
        $alts$  & ::= & $alt_1; \ldots ; alt_n$ \\
        $alt$   & ::= & $pattern \rightarrow t$ \\
    \end{tabular}
    \caption{Grammar}
    \label{tab:grammar}
\end{table}

\subsection{Typing}

\begin{table}
    \centering
    \begin{tabular}{rcll}
        $\varphi$ &               $\in$ & \textbf{Ann}                   & annotations \\ 
        $\widehat{\tau}$&         $\in$ & $\widehat{\textbf{Ty}      } $ & annotated types \\
        $\widehat{\sigma} $&      $\in$ & $\widehat{\textbf{TyScheme}} $ & annotated type schemes\\
        $\widehat{\Gamma}$&       $\in$ & $\widehat{\textbf{TyEnv}   } $ & annotated type environments  \\
    \end{tabular}
    \caption{Typing elements, annotated types}
    \label{tab:typingelems}
\end{table}
\begin{table}
    \centering
    \begin{tabular}{lcl}
        $ \varphi$         & ::= & $ \emptyset \:|\: \{\pi\} \:|\: \varphi_1 \cup \varphi_2 $ \\
        $\widehat{\tau}$   & ::= & $\alpha \:|\: Nat \: | \: Bool \: | \: \widehat{\tau}_1 \stackrel{\varphi}{\rightarrow} \widehat{\tau}_2 \:|\: \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 \:|\: \widehat{\tau}~\texttt{list}^\varphi   $ \\ 
        $\widehat{\sigma}$ & ::= & $\widehat{\tau} \:|\: \forall \alpha. \widehat{\sigma}_1 $ \\ 
        $\widehat{\Gamma}$ & ::= & $[\,] \:|\: \widehat{\Gamma}_1[x \mapsto \widehat{\sigma}] $ \\
    \end{tabular}
    \caption{Typing}
    \label{tab:typing}
\end{table}

This is the control-flow analysis: 
\fbox{$\widehat{\Gamma}\:\vdash_{CFA} t : \widehat{\sigma}$}

\subsection{Natural semantics}

We have the usual set of rules including, for example,  \emph{cfa-var} or \emph{cfa-let}, which has been extended to support lists, see \emph{cfa-nil} and \emph{cfa-cons}, the rules specifying list-typing. 

\begin{table}
    \centering
    \begin{tabular}{ll}
        $ [$\emph{cfa-var}$] $& \inference{\widehat{\Gamma}(x) = \widehat{\sigma}}
{\widehat{\Gamma} |-_{CFA} x  : \widehat{\sigma}} \\
~&~\\
$[$\emph{cfa-let}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma}_1 
& \widehat{\Gamma}[x \mapsto \widehat{\sigma}_1] |-_{CFA} t_2 : \widehat{\tau}}
{\widehat{\Gamma} |-_{CFA}\: \<let>\: x = t_1\: \<in>\: t_2 : \widehat{\tau}} \\
~&~\\
$[$\emph{cfa-nil}$] $& 
\inference{}
{\widehat{\Gamma} |-_{CFA} [\,] : [\widehat{\sigma}]} \\
~&~\\
$[$\emph{cfa-cons}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1:\widehat{\sigma} 
 \widehat{\Gamma}|-_{CFA} t_2 : [\widehat{\sigma}]}
{\widehat{\Gamma} |-_{CFA} t_1 \<:> t_2 :  [\widehat{\sigma}]} \\
~&~\\
$[$\emph{cfa-pair}$] $& \inference{\widehat{\Gamma} |-_{CFA} t_1 : \widehat{\tau}_1 &  \widehat{\Gamma} |-_{CFA} t_2 : \widehat{\tau}_2   } 
{\widehat{\Gamma} |-_{CFA} (t_1,t_2) : \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 } \\
~&~\\
$[$\emph{cfa-case-pair}$] $& \inference{\widehat{\Gamma} |-_{CFA} e_0 : \widehat{\tau}_1 \times^\varphi \widehat{\tau}_2 
&  \widehat{\Gamma} |-_{CFA} e_1 : \widehat{\tau}   } 
{\widehat{\Gamma} |-_{CFA} \texttt{case } e_1 \texttt{ of }(x_1,x_2) \Rightarrow e_1 : \widehat{\tau} } \\

%todo still: cfa-case-list.  also, natural semantics for cases. 

    \end{tabular}
    \caption{Control flow analysis rules. }
    \label{tab:cfa-rules}
\end{table}

\section{Approach}


\section{Implemented}

\section{Example programs}

%todo: this probably needs fixing. 
\begin{itemize}
    \item \texttt{app.hm} An illustration of the function application in action. 
    \item \texttt{assignment.hm} The example program from the assignment, with
        the correct output. 
    \item \texttt{identity.hm} The simplest possible program, the identity
        function. 
    \item \texttt{inf.hm} Gives a type error, correctly (the program, $\lambda
        x.
        \lambda y . (y x) (x y)$ isn't typable and leads to a so-called
        \emph{occurs check\footnote{Meaning that the unification algorithm would
        have to introduce an infinite type to succeed.}}).
    \item \textit{singleton.hm} Simply illustrates a variable which is out of
        scope. 
\end{itemize}

\end{document}
