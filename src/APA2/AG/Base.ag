imports
{
import Data.Set (Set)
}

{
type TyVar  = String
type Var    = String
type Point  = String
type AnnVar = String
type Constraints = Set Constraint
}
-------------------------------------------------------------------------------
-- Syntax
-------------------------------------------------------------------------------

-- Language definition for Mini Haskell
DATA MH
  | VBool  v  : {Bool}
  | VInt   v  : {Integer}
  | Var    x  : {Var}
  | Op     op : String e1 : MH          e2 : MH
  | Lambda x  : {Var}  e  : MH
  | App    e1 : MH     e2 : MH
  | Let    x  : {Var}  e1 : MH          e2 : MH
  | LetRec f  : {Var}  x  : {Maybe Var} e1 : MH e2 : MH
  | If     c  : MH     e1 : MH          e2 : MH
  | Cons   e1 : MH     e2 : MH
  | Nil

DERIVING MH: Eq

DATA TyScheme
  | Ty     ty : Ty
  | Forall a : {TyVar}  ts : TyScheme
  | AnnSig a : {AnnVar} ts : TyScheme

DERIVING TyScheme: Show, Eq

DATA Ty
  | TyVar a   : {TyVar}
  | Arr   ty1 : Ty ty2 : Ty     ann : SAnn
  | List  ty  : Ty ann : SAnn -- builtin List is an addition
  | Nat
  | Bool

DERIVING Ty: Eq

-- | We need to make the set operations explicit, since it is also possible to
-- have something like β∪{h}

DATA SAnn
  | AnnVar   var    : {AnnVar}
  | AnnUnion a1     : SAnn        a2 : SAnn
  | AnnEmpty
  | AnnSet   points : {Set Point}

DERIVING SAnn: Show, Eq, Ord

DATA Constraint
  | Constraint a1 : SAnn a2 : SAnn

DERIVING Constraint: Show, Eq, Ord

DATA SimpleSubstitution
  | Identity
  | TySub  tv : {TyVar} t  : Ty
  | AnnSub a1 : SAnn    a2 : SAnn -- annotation substitution
  | Dot    s1 : SimpleSubstitution s2 : SimpleSubstitution

{
instance Show MH where
  show (VBool  v          ) = show v
  show (VInt   v          ) = show v
  show (Var    x          ) =      x
  show (Op     op e1 e2   ) = show e1 ++ op ++ show e2
  show (Lambda x  e       ) = "\\ "++x++" -> " ++ show e
  show (App    e1 e2      ) = show e1 ++ show e2
  show (Let    x  e1 e2   ) = "let "++ x ++" = " ++ show e1 ++ " in " ++ show e2
  show (LetRec f  x  e1 e2) = "mu " ++ show f ++ ".let "++ fromMaybe "undef" x ++" = " ++ show e1 ++ " in " ++ show e2
  show (If     c  e1 e2   ) = "if "++show c++" then " ++ show e1 ++ " else " ++ show e2
  show (Cons   e1 e2      ) = show e1 ++ ":"++show e2
  show (Nil               ) = "[]"

instance Show Ty where
  show (TyVar a)    = a
  show (Arr t t' a) = show t ++ "--"++ show a ++ "-->" ++ show t'
  show Nat          = "Nat"
  show Bool         = "Bool"
  show (List t an)  = "List^{" ++ show an ++ "} " ++ show t

instance Show SimpleSubstitution where
  show Identity      = ""
  show (TySub v t)   = v ++ " |-> " ++ show t
  show (AnnSub a a') = show a ++ " |-> " ++ show a'
  show (Dot s Identity) = show s
  show (Dot s s')       = show s ++ "\n" ++ show s'

}
