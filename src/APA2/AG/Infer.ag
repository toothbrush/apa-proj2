imports
{
import            Control.Monad ()
}

ATTR MH
  [ -- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  |
   -- The algW attribute will contain the type of the term.
    ty : {Ty}
    constraints USE {`DS.union`} {DS.empty} : {Constraints}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution                            : {SimpleSubstitution}
    lhsTy     USE {`mplus`} {Nothing}       : {Maybe Ty}
    annotation                              : {Maybe AnnVar}
    debug     USE {++} {""}                 : {String}
    annotDict USE {`DM.union`} {DM.empty}   : {Map String MH}
    cp : SELF
  ]

SEM MH
  | VBool
      lhs.annotation   = Nothing
      lhs.constraints  = DS.empty
      lhs.substitution = Identity
      lhs.ty           = Bool

  | VInt
      lhs.annotation   = Nothing
      lhs.constraints  = DS.empty
      lhs.substitution = Identity
      lhs.ty           = Nat

  | Nil
      loc.alpha : UNIQUEREF counter
      loc.beta  : UNIQUEREF counter

      loc.alpha' = freshVar @loc.alpha
      loc.beta'  = mkAnnVar @loc.beta

      lhs.ty = List @loc.alpha' (DS.singleton @loc.beta')

      lhs.substitution = Identity

      lhs.constraints = DS.empty

      lhs.annotation = Nothing

  | Cons
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      loc.listTy = List @e1.ty (DS.singleton @loc.beta')
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify @e2.ty (applySubst @loc.theta2 @loc.listTy)
      loc.theta  = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      lhs.ty = applySubst @loc.theta @loc.listTy

-- TODO: Substs?
      lhs.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            cs = c1 `DS.union` c2
        in applySubst @loc.theta cs 

      lhs.annotation = Nothing

      e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Op -- TODO: Verify
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta

      loc.(ty,ty',r) = operatorType @op

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'

      loc.th43  = @loc.theta4 `dot` @loc.theta3
      loc.th432 = @loc.th43 `dot` @loc.theta2
      loc.theta = @loc.th432 `dot` @loc.theta1

      lhs.ty = @loc.r

      lhs.substitution = @loc.theta

      lhs.constraints =
        let c1 = applySubst @loc.th432 @e1.constraints
            c2 = applySubst @loc.th43 @e2.constraints
        in c1 `DS.union` c2

      e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment

      lhs.annotation = Nothing

  | Var
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

-- TODO: Do we need this at all here?
      {- loc.phi = trace ("does the (?) break here? "++ @x++"?"++ppMap @lhs.annEnvironment ) $ -}
                {- @x ? @lhs.annEnvironment-}

      loc.(c, ty) =
        maybe (error ("Variable "++ @x ++" not found in environment (out of scope)."))
              (instantiate @loc.beta)
              (DM.lookup @x @lhs.typeEnvironment)

      -- this does not work for a case like: let f = \x -> true in let g = \k -> if f 0 then k else \y -> false in g f
      loc.constraints  = @loc.c
      loc.substitution = Identity

      lhs.annotation   = Nothing
      lhs.constraints  = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.ty           = @loc.ty

      lhs.debug = "Var("++ @x ++ "): \n" ++
                  "tyEnv: " ++ ppMapStr @lhs.typeEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ ppSet @loc.constraints ++ "\n\n"

  | Lambda
      loc.alpha  : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha' = freshVar @loc.alpha
      loc.beta'  = mkAnnVar @loc.beta
      loc.pi     = mkProgramPoint @x @loc.ppoint

      loc.constraints  = @e.constraints `DS.union` (@loc.beta' <:? (AnnPts $ DS.singleton @loc.pi))
      loc.substitution = @e.substitution
      loc.ty           = Arr (applySubst @loc.substitution @loc.alpha') @e.ty (DS.singleton @loc.beta')

      lhs.annotation   = Just @loc.pi
      lhs.constraints  = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.ty           = @loc.ty

      e.typeEnvironment = DM.insert @x (Ty @loc.alpha') @lhs.typeEnvironment

      lhs.annotDict = DM.singleton @loc.pi @loc.cp
                        `DM.union` @e.annotDict

      lhs.debug = "Lambda("++ @x ++ "): \n" ++
                  "tyEnv: " ++ ppMapStr @lhs.typeEnvironment ++ "\n" ++
                  "ty: " ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ @loc.pi ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ ppSet @loc.constraints ++ "\n\n" ++
                  @e.debug


  | App
      loc.alpha : UNIQUEREF counter
      loc.beta  : UNIQUEREF counter

      loc.alpha' = freshVar @loc.alpha
      loc.beta'  = mkAnnVar @loc.beta

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                         (Arr @e2.ty @loc.alpha' (DS.singleton @loc.beta'))

      loc.substitution = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      loc.ty = applySubst @loc.theta3 @loc.alpha'

      loc.constraints =
        let c1  = @e1.constraints
            c2  = @e2.constraints
            sc1 = applySubst (@loc.theta3 `dot` @loc.theta2) c1
            sc2 = applySubst @loc.theta3 c2
        in  sc1 `DS.union` sc2

      lhs.annotation   = Nothing
      lhs.constraints  = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.ty           = @loc.ty

      e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

      lhs.debug = "App: \n" ++
                  "tyEnv: " ++ ppMapStr @lhs.typeEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ ppSet @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug


  | Let
      loc.beta : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution

      loc.constraints  = let c1 = @e1.constraints
                             c2 = applySubst @loc.theta2 @e2.constraints
                         in  c1 `DS.union` c2
      loc.substitution = @loc.theta2 `dot` @loc.theta1
      loc.ty           = @e2.ty

      lhs.annotation   = Nothing
      lhs.constraints  = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty

      e2.typeEnvironment =
        let newEnv  = applySubst @e1.substitution @lhs.typeEnvironment
            gen ann = snd $ generalise newEnv ann @e1.ty @e1.constraints
            ty'     = maybe (Ty @e1.ty) (gen . DS.singleton) @e1.annotation
        in  DM.insert @x ty' newEnv

      lhs.debug = "Let("++ @x ++ "): \n" ++
                  "tyEnv: " ++ ppMapStr @lhs.typeEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ ppSet @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter
      loc.beta1  : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta
      loc.beta''  = mkAnnVar @loc.beta1
      loc.pi      = mkProgramPoint @f @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      -- | not sure about correctness
      lhs.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
        in c1 `DS.union` c2

      loc.annotation = Nothing -- Just (AnnVar @loc.beta'')
      lhs.annotation = @loc.annotation

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (Ty $ Arr @loc.alpha1' @loc.alpha2' (DS.singleton @loc.beta')) (
                      DM.insert x (Ty @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (Ty @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty      = Arr (applySubst @loc.theta @alpha1')
                                         (applySubst @loc.theta1 @e1.ty)
                                         (DS.singleton $ applySubst @loc.theta @loc.beta')
                           gen ann = snd $ generalise newEnv ann ty @e1.constraints
                           ty'     = maybe (Ty ty) gen @loc.annotation
                       in  DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (Ty @loc.alpha2') newEnv

      lhs.annotDict = DM.singleton @loc.pi @loc.cp
                          `DM.union` @e2.annotDict
                          `DM.union` @e1.annotDict

  | If
      loc.beta1  : UNIQUEREF counter
      loc.beta2  : UNIQUEREF counter
      loc.beta3  : UNIQUEREF counter
      loc.beta'  = mkAnnVar @loc.beta1 -- Condition annotation
      loc.beta2' = mkAnnVar @loc.beta2 -- Then annotation
      loc.beta3' = mkAnnVar @loc.beta3 -- Else annotation

      loc.theta1 = @c.substitution
      loc.theta2 = @e1.substitution
      loc.theta3 = @e2.substitution
      loc.theta4 = unify (applySubst (@loc.theta3 `dot` @loc.theta2) @c.ty) Bool
      loc.theta5 = unify (applySubst @loc.theta4 @e2.ty)
                         (applySubst (@loc.theta4 `dot` @loc.theta3) @e1.ty)

      loc.th5432 = @loc.th543  `dot` @loc.theta2
      loc.th543  = @loc.th54   `dot` @loc.theta3
      loc.th54   = @loc.theta5 `dot` @loc.theta4

      loc.substitution = @loc.theta5 `dot` @loc.theta4 `dot` @loc.theta3 `dot`
                         @loc.theta2 `dot` @loc.theta1

{-
If neither branch has a function type, we're done for now.

If both branches have a function type, they both have their own annotations
and constraints. We union the constraints and then we're done.

If one branch has a function type and the other doesn't, we first unify the
types and then give the newly found Arr type a fresh annotation variable. This
fresh annotation variable is then unioned with the annotation variables on the
existing Arr.
-}

      loc.ty = case (@e1.ty, @e2.ty) of
                 (Arr _ _ c1, t2@(Arr a b c2)) -> Arr a b (c1 `DS.union` c2)
                 (Arr _ _ cs, t2) -> let (Arr a1 a2 _) = applySubst @loc.theta5 t2
                                     in  Arr a1 a2 (DS.insert @loc.beta3' cs)
                 (t1, Arr _ _ cs) -> let (Arr a1 a2 _) = applySubst @loc.theta5 t1
                                     in  Arr a1 a2 (DS.insert @loc.beta2' cs)
                 (_, t2) -> t2

      loc.constraints =
        let c1 = applySubst @loc.th5432 @c.constraints
            c2 = applySubst @loc.th543  @e1.constraints
            c3 = applySubst @loc.th54   @e2.constraints
        in  c1 `DS.union` c2 `DS.union` c3

      lhs.annotation   = Nothing
      lhs.constraints  = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.ty           = @loc.ty

      e1.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment
      e2.typeEnvironment = applySubst (@loc.theta2 `dot` @loc.theta1) @lhs.typeEnvironment

      lhs.debug = "If: \n" ++
                  "tyEnv: " ++ ppMapStr @lhs.typeEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ ppSet @loc.constraints ++ "\n\n" ++
                  @c.debug ++ @e1.debug ++ @e2.debug
  | CaseBlck
      loc.beta : UNIQUEREF counter
      loc.beta' = mkAnnVar @loc.beta

      -- TODO: Unify types of case (expression) of and the left-hand sides of
      -- the individual case blocks
      -- Then unify the types of the right-hand side of the individual case
      -- blocks

      -- TODO: See if we need some substitutions here...
      loc.theta0 = @ex.substitution
      loc.theta1 = unify @ex.ty (applySubst @loc.theta0 $ fromJust @c1.lhsTy)
      loc.theta2 = trace "theta2" $ unify @ex.ty (applySubst (@loc.theta1 `dot` @loc.theta0) $ fromJust @c2.lhsTy)
      loc.lhsTheta = @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.theta3 = @c1.substitution
      loc.theta4 = @c2.substitution
      -- FIXME: This is where shit is currently hitting the fan
      loc.theta5 = unify (applySubst @loc.lhsTheta @c1.ty)
                         (applySubst (@loc.theta3 `dot` @loc.lhsTheta) @c2.ty)
      loc.theta = @loc.theta5 `dot` @loc.theta4 `dot` @loc.theta3 `dot` @loc.lhsTheta

      loc.ty = applySubst @loc.theta @c1.ty
      lhs.ty = @loc.ty

      lhs.constraints =
        let c1 = @ex.constraints
            c2 = @c1.constraints
            c3 = @c2.constraints
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta cs


      lhs.substitution = @loc.theta
      lhs.annotation = @loc.annotation
      loc.annotation =
        case @loc.ty of
          Arr _ _ _ -> Just @loc.beta'
          _         -> Nothing

      c1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      c2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta3) @lhs.typeEnvironment
  | CaseAlt
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      lhs.constraints = @bnd.constraints

      loc.theta  = @pat.substitution
      loc.ty = applySubst @loc.theta @bnd.ty
      lhs.ty = @loc.ty
      lhs.substitution = @loc.theta

      lhs.annotation = Nothing

      lhs.lhsTy = Just @pat.ty



{
freshVar :: Int -> Ty
freshVar i = TyVar $ 'τ' : show i

mkAnnVar :: Int -> AnnVar
mkAnnVar i = 'β' : show i

mkProgramPoint :: Var -> Int -> Point
mkProgramPoint v p = 'π' : v ++ show p

operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-", "+", "*"]              = (Nat, Nat, Nat)
  | op `elem` ["==", "<", ">", "<=", ">="] = (Nat, Nat, Bool)
  | otherwise                              = error $ "Invalid op: " ++ op

(<:?) :: AnnVar -> RhsConstr -> Constraints
v <:? phi = DS.singleton (Constraint v phi)

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

generalise :: TyEnv -> SAnn -> Ty -> Constraints -> (Constraints, TyScheme)
generalise env ann tau c =
  let ftvs   = ftv tau DS.\\ ftv env
      favs   = fav tau DS.\\ fav env DS.\\ ann
      (c', c'') = simplify env tau c
      qtdTVs = DS.fold Forall (Ty tau) ftvs
      qtdAVs = DS.fold AnnSig qtdTVs favs
  in  (c'', qtdAVs)

instantiate :: Int -> TyScheme -> (Constraints, Ty)
instantiate seed ts = (applySubst subst cs, applySubst subst ty)
  where (Binders tyvars annvars cs ty) = collectBinders ts
        fresh   pfx = map (\x -> pfx : show seed ++ show x) ([0..] :: [Int])
        tySubs      = zipWith (\a b -> TySub a (TyVar b)) tyvars (fresh 'τ')
        annSubs     = zipWith AnnSub annvars (fresh 'β')
        subst       = foldr Dot Identity (tySubs ++ annSubs)

}
