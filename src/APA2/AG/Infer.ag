optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import Debug.Trace
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Map as Map
import            Data.MultiSet (MultiSet)
import qualified  Data.MultiSet as DMS
import qualified  Data.Set as DS
import            Data.Maybe
}

ATTR MH
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    constraints  : {Constraints}
  ]

SEM MH
  | VBool lhs.ty = Bool
          lhs.substitution = Identity
          lhs.constraints = DS.empty

  | VInt  lhs.ty = Nat
          lhs.substitution = Identity
          lhs.constraints = DS.empty

  | Nil   loc.num : UNIQUEREF counter

          lhs.ty = List (TyVar $ show @loc.num) (AnnVar "g")

          lhs.substitution = Identity

          lhs.constraints = DS.empty

  | Cons  lhs.ty = let tau1   = @e1.ty
                       theta1 = @e1.substitution
                       tau2   = @e2.ty
                       theta2 = @e2.substitution
                       theta3 = unify tau2 (applySubst theta2 (List tau1 (AnnVar "g")))
                       theta  = theta3 `dot` theta2 `dot` theta1
                   in applySubst theta (List tau1 (AnnVar "g"))

          lhs.constraints = DS.empty

          e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Op    loc.alpha1 : UNIQUEREF counter
          loc.alpha2 : UNIQUEREF counter

          loc.alpha1' = freshVar @loc.alpha1
          loc.alpha2' = freshVar @loc.alpha2

          loc.(ty,ty',r) = operatorType @op

          loc.theta1 = @e1.substitution
          loc.theta2 = @e2.substitution
          loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
          loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'

          lhs.ty = @loc.r

          lhs.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

          lhs.constraints = let th43 = @loc.theta4 `dot` @loc.theta3
                            in DS.union (applySubst (th43 `dot` @loc.theta2) @e1.constraints)
                                        (applySubst th43 @e2.constraints)

          e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment

  | Var loc.num : UNIQUEREF counter

        lhs.ty = if @x `DM.member` @lhs.typeEnvironment
                     then instantiate $ getVar @x @lhs.typeEnvironment
                     else error ("Variable "++ @x ++" not found in environment (out of scope).")

        lhs.constraints = DS.empty

        lhs.substitution = Identity

  | Lambda loc.num     : UNIQUEREF counter
           loc.ppoint  : UNIQUEREF counter
           loc.beta    : UNIQUEREF counter

           loc.beta' = mkAnnVar @loc.beta
           loc.pi    = mkProgramPoint @x @loc.ppoint
           loc.alpha = freshVar @loc.num

           lhs.substitution = @e.substitution

           lhs.ty = let theta1 = @e.substitution
                        tau2   = @e.ty
                    in Arr (applySubst theta1 @loc.alpha) tau2 @loc.beta'

           lhs.constraints = DS.union @e.constraints (DS.singleton (@loc.beta' `constrain` @loc.pi))

           e.typeEnvironment = DM.insert @x (Ty $ @loc.alpha) @lhs.typeEnvironment

  | App loc.alpha : UNIQUEREF counter
        loc.beta  : UNIQUEREF counter

        loc.beta' = mkAnnVar @loc.beta

        loc.alpha'  = freshVar @loc.alpha
        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                           (Arr @e2.ty @loc.alpha' @loc.beta')
        loc.theta = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = applySubst @loc.theta3 @loc.alpha'

        lhs.constraints = DS.union (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.constraints)
                                   (applySubst @loc.theta3 @e2.constraints)

        e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Let loc.num : UNIQUEREF counter

        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta  = @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = @e2.ty

        lhs.constraints = DS.union (applySubst @loc.theta2 @e1.constraints) @e2.constraints

        e2.typeEnvironment = let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
                                 ty'    = generalise newEnv @e1.ty -- TODO: does the constraint here make sense (specifically, is e1 right?)
                             in  DM.insert @x ty' newEnv

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec 
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta
      loc.pi      = mkProgramPoint @f @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      lhs.constraints = DS.union (applySubst @loc.theta1 @e1.constraints)
                                 (DS.singleton ((applySubst @loc.theta @loc.beta') `constrain` @loc.pi))

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (Ty $ Arr @loc.alpha1' @loc.alpha2' @loc.beta') (
                      DM.insert x (Ty $ @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (Ty $ @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty = Arr (applySubst @loc.theta @alpha1')
                                    (applySubst @loc.theta1 @e1.ty)
                                    (applySubst @loc.theta @loc.beta')
                           ty' = generalise newEnv ty
                       in DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (Ty $ @loc.alpha2') newEnv

  | If loc.theta0 = @c.substitution
       loc.theta1 = @e1.substitution
       loc.theta2 = @e2.substitution
       loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @loc.tau0) Bool
       loc.theta4 = unify (applySubst @loc.theta3 @loc.tau2)
                          (applySubst (@loc.theta3 `dot` @loc.theta2) @loc.tau1)
       loc.theta = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

       loc.tau0 = @c.ty
       loc.tau1 = @e1.ty
       loc.tau2 = @e2.ty

       lhs.ty = applySubst @loc.theta @loc.tau2

       lhs.constraints = 
        let th43  = @loc.theta4 `dot` @loc.theta3
            th432 = th43 `dot` @loc.theta2
            c0 = applySubst (th432 `dot` @loc.theta1) @c.constraints
            c1 = applySubst th432 @e1.constraints
            c2 = applySubst th43 @e1.constraints
        in DS.union c0 (DS.union c1 c2)

       lhs.substitution = @loc.theta

{
-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in a Tm with type lambdas at the right spots.
generalise :: TyEnv -> Ty -> TyScheme
generalise env tau = let free      = fv tau DS.\\ fv env
                         genTyVars = DS.fold Forall (Ty tau) free
                         annots    = fav tau -- TODO: exclude anything?
                     in DS.fold AnnSig genTyVars annots

{-
generalise :: TyEnv -> Ty -> Constraints -> (Constraints, TyScheme) -- I'm assuming there's no need for Annotations here?
generalise env     tau c = let (c', c'')   = simplify env tau c
                               freeAlpha   = fv  tau DS.\\ fv  env
                               freeBeta    = fav tau -- onzin? : DS.\\ fav env -- DS.\\ fav ann
                               freeBeta'   = fav c'  DS.\\ fav tau -- onzin? : DS.\\ fav env -- DS.\\ fav ann
                               genTyVars   = DS.fold Forall (Ty tau) freeAlpha
                               --genAnnVars  = DS.fold Forall (genTyVars) (freeBeta `DS.union` freeBeta')
                           in  {- trace (show annots) $ -}
                               (c'', DS.fold AnnSig genTyVars (freeBeta `DS.union` freeBeta'))
-}

-- | Simplify constraints. 
simplify :: TyEnv -> Ty -> Constraints -> (Constraints, Constraints)
simplify env tau c = let active = pseudoActive (DS.map AnnVar ({- fav env `DS.union` -} fav tau)) c
                         ranges = range c
                         theta  = satisfiable active ranges
                         c'     = applySubst theta c
                     in  partition env c'

pseudoActive :: Set SAnn -> Constraints -> Set AnnVar
pseudoActive active c =
  let extrAnn (Constraint l u) xs | l `DS.member` active = DS.insert u xs
                                  | otherwise            = xs
      vars = DS.fold extrAnn DS.empty c `DS.union` active
  in  if DS.null (vars `DS.intersection` active)
        then pseudoActive vars c
        else let extrVar (AnnVar x) xs = DS.insert x xs
                 extrVar _          xs = xs
             in DS.fold extrVar DS.empty vars

range = error "no range"

satisfiable :: Set AnnVar -> Map SAnn (SAnn, SAnn) -> SimpleSubstitution
satisfiable active analysis =
  let act'          = DS.map AnnVar active
      func beta (l, u)
        | l <= u    = if beta `DS.notMember` act' || l == u
                        then AnnSub beta l
                        else Identity
        | otherwise = error "lower bound is larger than upper bound"
      substLst      = DM.mapWithKey func analysis
  in DM.fold Dot Identity substLst

--partition :: TyEnv -> Constraints -> ( , )
partition env cs = (cs,DS.empty)
{- for this we need (instance (FreeAnnVars TyEnv)), but that doesn't make sense, right?
                   let active = DS.map AnnVar $ fav env
                       prop   = DS.fromList [ Constraint l u | Constraint l u <- cs, l `DS.member` active || u `DS.member` active ]
                       qual   = DS.fromList [ pi | pi <- cs, pi `DS.notMember` prop]
                   in  (prop, qual)
                   -}

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, forallAVars, ty') = grabForallVars ts
      sfold c = foldr (\(o,n) -> Dot (c o n)) Identity
      nzip  c = zipWith (\a b -> c (a ++ b)) forallVars (map show ([0..] :: [Int]))
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      s  = sfold TySub (zip forallVars $ nzip TyVar)
      -- do kinda the same for annotation variables.
      s' = sfold AnnSub (zip (map AnnVar forallAVars) $ nzip AnnVar)
  in  {-trace (show finalSub) $ -}
      applySubst (Dot s s') ty'

-- | These operators are pretty dull
operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-","+","*"]            = (Nat, Nat, Nat)
  | op `elem` ["==","<",">","<=",">="] = (Nat, Nat, Bool)
  | otherwise                          = error $ "Invalid op: " ++ op

-- | Turn a number (the counter's current value) into a type variable.
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program.
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

mkAnnVar :: Int -> SAnn
mkAnnVar i = AnnVar ("b" ++ show i)

mkProgramPoint :: Var -> Int -> SAnn
mkProgramPoint v p = AnnSet (DS.singleton (v ++ (show p))) 

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], [AnnVar], Ty)
grabForallVars (Ty t)          = ([], [], t)
grabForallVars (Forall tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (tv:vars, avars, ty)
-- now with Annotation super powers
grabForallVars (AnnSig tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (vars, tv:avars, ty)

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. '" ++ x ++
                          "'\nwasn't found in the environment.")

constrain :: SAnn -> SAnn -> Constraint
constrain var@(AnnVar _) p = Constraint var p
constrain _              _ = error "invalid constraint"

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

dotApply :: Substitutable t => SimpleSubstitution -> t -> t
dotApply (Dot s1 s2) t = applySubst s1 (applySubst s2 t)
dotApply _           _ = error "not allowed"

-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> SimpleSubstitution

unify Nat  Nat  = Identity
unify Bool Bool = Identity

unify (List t an) (List t' an') = let theta1 = unify t t'
                                      theta2 = unifyAnn (applySubst theta1 an) (applySubst theta1 an')
                                  in theta2 `dot` theta1

unify t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                    | tv1 `DS.notMember` fv t2 = TySub tv1 t2
                                    | tv2 `DS.notMember` fv t1 = TySub tv2 t1
                                    | otherwise = error "Cannot unify. Error."

unify (TyVar tv1) t | tv1 `DS.notMember` fv t = TySub tv1 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify t (TyVar tv2) | tv2 `DS.notMember` fv t = TySub tv2 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify (Arr t11 t12 an) (Arr t21 t22 an') =
  let theta1 = unify t11 t21
      theta2 = unify (applySubst theta1 t12)
                     (applySubst theta1 t22)
      theta3 = let th21 = theta2 `dot` theta1
               in unifyAnn (applySubst th21 an) (applySubst th21 an')
  in theta3 `dot` theta2 `dot` theta1

unify t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2

unifyAnn :: SAnn -> SAnn -> SimpleSubstitution
unifyAnn a@(AnnVar v) b@(AnnVar v')
  | v == v'   = Identity
  | otherwise = AnnSub b a
unifyAnn a1 a2 = error $ "Annotation unification failure. \na_1 = " ++
                      show a1 ++ "\na_2 = " ++
                      show a2

class Ord a => Lattice a where
  top     :: a
  bottom  :: a
  join    :: a -> a -> a
  pord    :: a -> a -> Bool

{-
eval :: SAnn -> Map AnnVar SAnn -> SAnn
eval t ana = t -- DS.fold o AnnEmpty (fav t)
  where o x = annUnion (fromJust $ DM.lookup x ana)
-}

eval :: SAnn -> Map AnnVar SAnn -> SAnn
eval a@(AnnVar v) ana = fromJust $ DM.lookup v ana
eval AnnEmpty _       = AnnEmpty
eval a@(AnnSet _) _   = a
eval a@(AnnUnion _ _) ana = annUnion (AnnSet $ annPoints a) (DS.fold o AnnEmpty (fav a))
  where o x = annUnion (fromJust $ DM.lookup x ana)

worklist :: Constraints -> (SAnn -> Map AnnVar SAnn -> SAnn) -> Map AnnVar SAnn
worklist constraints eval = repeatStep w initialAna
  where
  initialAna = DS.fold o DM.empty constraints
    where o c@(Constraint (AnnVar v) a@(AnnSet _)) = DM.union (DM.singleton v a)
          o c@(Constraint (AnnVar v) x) = DM.union (DM.singleton v (bottom :: SAnn))
          o _                           = DM.union DM.empty
{-
  initialAna = DS.fold o DM.empty constraints
    where o c@(Constraint (AnnVar v) x) = DM.union (DM.singleton v (bottom :: SAnn))
          o _                           = DM.union DM.empty
-}
  w = DS.fold o DMS.empty constraints
    where o c@(Constraint (AnnVar v) x) = DMS.union (DMS.singleton c)
          o _                           = DMS.union DMS.empty

  infl = DS.fold o DM.empty constraints
    where o c@(Constraint (AnnVar v) _) = DM.union (DM.singleton v DS.empty)
          o _                           = DM.union DM.empty

  infl' = DS.fold o DM.empty constraints
    where o c@(Constraint (AnnVar _) x) = DM.union (DM.mapWithKey (f (fav x) c) infl)
          o _                           = DM.union DM.empty

          f freeAnnVars c k x 
            | k `DS.member` freeAnnVars = x `DS.union` (DS.singleton c)
            | otherwise                 = DS.empty

  repeatStep w ana 
    | DMS.null w = ana
    | otherwise  = let (w', ana') = trace ("step( W: " ++ show w ++ ", ANA: " ++ show ana ++ ")\n\n") step infl' eval w ana
                   in repeatStep w' ana'

type Worklist = MultiSet Constraint
type EvalFunc = SAnn -> Map AnnVar SAnn -> SAnn
type Influence = Map AnnVar Constraints
type Analysis = Map AnnVar SAnn

step :: Influence
     -> EvalFunc
     -> Worklist
     -> Analysis
     -> (Worklist, Analysis)
step infl eval w ana
  | DMS.null w              = (w, ana)
  | not $ xInAna `pord` new = trace "do body" body
  | otherwise               = (w', ana)
  where
  (Constraint (AnnVar v) t, w') = let c = DMS.findMin w
                                  in (c, DMS.delete c w)
  new    = eval t ana  
  xInAna = fromJust $ DM.lookup v ana
  
  body = let newAna = DM.insert v (xInAna `join` new) ana
             w''    = DS.fold o w' (fromJust $ DM.lookup v infl)
             o c@(Constraint (AnnVar _) _) = DMS.insert c
             o _                           = id
         in (w'', newAna)

instance Lattice SAnn where
  top    = error "SAnn does not have a concrete Top value"
  bottom = AnnSet DS.empty
  join   = annUnion
  pord   = (>=)

annUnion :: SAnn -> SAnn -> SAnn
annUnion AnnEmpty AnnEmpty = AnnEmpty
annUnion AnnEmpty x        = x
annUnion x AnnEmpty        = x
annUnion (AnnSet s) (AnnSet s') = AnnSet (DS.union s s')
annUnion a@(AnnSet _) a'        = AnnUnion a a'
annUnion a@(AnnVar v) a'
  | containsAnnVar v a' = a'
  | otherwise           = AnnUnion a a'
annUnion a@(AnnUnion _ _) a'@(AnnVar v)
  | containsAnnVar v a = a
  | otherwise          = AnnUnion a a'
annUnion b@(AnnUnion _ _) c@(AnnSet _)     = AnnUnion b c
annUnion a@(AnnUnion _ _) b@(AnnUnion _ _) = mkDisjoint a b

annPoints :: SAnn -> Set Point
annPoints AnnEmpty = DS.empty
annPoints (AnnSet s) = s
annPoints (AnnVar _) = DS.empty
annPoints (AnnUnion a b) = annPoints a `DS.union` annPoints b

containsAnnVar :: AnnVar -> SAnn -> Bool
containsAnnVar v (AnnVar v')    = v == v'
containsAnnVar v (AnnUnion a b) = containsAnnVar v a || containsAnnVar v b
containsAnnVar v (AnnSet _)     = False

-- maybe monad?
mkDisjoint :: SAnn -> SAnn -> SAnn
mkDisjoint c@(AnnUnion _ _) (AnnUnion b b') =
  let traverse x@(AnnVar v) | v `DS.member` fav c = Nothing
                            | otherwise           = Just x
      traverse x@(AnnSet _) = Just x
      traverse (AnnUnion y y') =
        case traverse y of
          Nothing -> case traverse y' of
                       Nothing -> Just AnnEmpty
                       Just x  -> Just x
          Just x  -> case traverse y' of
                       Nothing -> Just AnnEmpty
                       Just x' -> Just $ AnnUnion x x'
      traverse AnnEmpty = Just AnnEmpty
  in case traverse b of
       Nothing -> case traverse b' of
                    Nothing -> c
                    Just x  -> AnnUnion c x
       Just x  -> case traverse b' of
                    Nothing -> AnnUnion c x
                    Just x' -> AnnUnion c (AnnUnion x x')
mkDisjoint a b = error $ "Cannot mkDisjoint " ++ show a ++ " and " ++ show b

class Substitutable subject where
  applySubst :: SimpleSubstitution -> subject -> subject

-- TODO: check whether bound variables are not being substituted
instance Substitutable TyScheme where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t
  applySubst s             (AnnSig _ t) = applySubst s t
  applySubst s@(TySub a _) (Forall tv ts) | a == tv   = Forall tv ts
                                          | otherwise = Forall tv (applySubst s ts)
  applySubst sub (Ty t) = Ty $ applySubst sub t

instance Substitutable Ty where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t

  applySubst (TySub a t0) (TyVar t)
    | a == t    = t0
    | otherwise = TyVar t

  applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) (applySubst s ann)

  applySubst s (List t ann) = List (applySubst s t) (applySubst s ann)

  applySubst _ Nat  = Nat
  applySubst _ Bool = Bool

instance Substitutable TyEnv where
  applySubst s = DM.map (applySubst s)

instance Substitutable Constraint where
  applySubst Identity    cs     = cs
  applySubst d@(Dot _ _) cs     = dotApply d cs
  applySubst s (Constraint a b) = Constraint (applySubst s a) (applySubst s b)

instance Substitutable Constraints where
  applySubst s = DS.map (applySubst s)

instance Substitutable SAnn where
  applySubst Identity    a            = a
  applySubst d@(Dot _ _) a@(AnnVar _) = dotApply d a

  applySubst (AnnSub (AnnVar b) (AnnVar b')) a@(AnnVar b'')
    | b == b''  = AnnVar b'
    | otherwise = a

  applySubst _ a = a

class FreeVariables a where
  fv :: a -> Set TyVar -- alias String

class FreeAnnVars a where
  fav :: a -> Set AnnVar -- alias String

instance FreeVariables TyScheme where
  fv x = fv_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeVariables Ty where
  fv x = fv_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeVariables TyEnv where
  fv x = fv_Syn_TyEnv (wrap_TyEnv (sem_TyEnv x) Inh_TyEnv)

instance FreeAnnVars Ty where
  fav x = fav_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeAnnVars TyScheme where
  fav x = fav_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeAnnVars SAnn where
  fav (AnnVar v)       = DS.singleton v
  fav (AnnUnion a1 a2) = DS.union (fav a1) (fav a2)
  fav _                = DS.empty

instance FreeAnnVars Constraints where
  fav = DS.fold DS.union DS.empty . DS.map fav

instance FreeAnnVars Constraint where
  fav c = fav_Syn_Constraint (wrap_Constraint (sem_Constraint c) Inh_Constraint)
}

TYPE TyEnv = MAP {Var} TyScheme

ATTR TyScheme Ty TyEnv
  [|| fv  USE {`DS.union`} {DS.empty} : {Set TyVar}   -- alias String
  ]

ATTR TyScheme Ty Constraint SAnn
  [|| fav USE {`DS.union`} {DS.empty} : {Set AnnVar} -- alias String
  ]

SEM TyScheme
  | AnnSig lhs.fav = @ts.fav DS.\\ DS.singleton @a
  | Forall lhs.fv  = @ts.fv  DS.\\ DS.singleton @a

SEM Ty
  | TyVar lhs.fv = DS.singleton @a

SEM TyEnv
  | Entry lhs.fv = @val.fv `DS.union` @tl.fv
  | Nil   lhs.fv = DS.empty

SEM SAnn
  | AnnVar lhs.fav = DS.singleton @var
