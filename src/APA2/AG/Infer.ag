optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Maybe as DM
import qualified  Data.Set as DS
}

ATTR MH
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    constraints  : {Constraint}
  ]

SEM MH
  | VBool lhs.ty = Bool
          lhs.substitution = Identity
          lhs.constraints = EmptyConstr

  | VInt  lhs.ty = Nat
          lhs.substitution = Identity
          lhs.constraints = EmptyConstr

  | Nil   loc.num : UNIQUEREF counter

          lhs.ty = List (TyVar $ show @loc.num) (AnnVar "g")

          lhs.substitution = Identity

          lhs.constraints = EmptyConstr

  | Cons  lhs.ty = let tau1   = @e1.ty
                       theta1 = @e1.substitution
                       tau2   = @e2.ty
                       theta2 = @e2.substitution
                       theta3 = unify tau2 (applySubst theta2 (List tau1 (AnnVar "g")))
                       theta  = theta3 `dot` theta2 `dot` theta1
                   in applySubst theta (List tau1 (AnnVar "g"))

          lhs.constraints = EmptyConstr

          e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Op    loc.alpha1 : UNIQUEREF counter
          loc.alpha2 : UNIQUEREF counter

          loc.alpha1' = freshVar @loc.alpha1
          loc.alpha2' = freshVar @loc.alpha2

          loc.(ty,ty',r) = operatorType @op

          loc.theta1 = @e1.substitution
          loc.theta2 = @e2.substitution
          loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
          loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'

          lhs.ty = @loc.r

          lhs.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

          lhs.constraints = let th43 = @loc.theta4 `dot` @loc.theta3
                            in  UnionConstr (applySubst (th43 `dot` @loc.theta2) @e1.constraints)
                                            (applySubst th43 @e2.constraints)

          e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment

  | Var loc.num : UNIQUEREF counter

        lhs.ty = if @x `DM.member` @lhs.typeEnvironment
                     then instantiate $ getVar @x @lhs.typeEnvironment
                     else error ("Variable "++ @x ++" not found in environment (out of scope).")

        lhs.constraints = EmptyConstr

        lhs.substitution = Identity

  | Lambda loc.num     : UNIQUEREF counter
           loc.ppoint  : UNIQUEREF counter
           loc.beta    : UNIQUEREF counter

           loc.beta' = annVar @loc.beta
           loc.pi    = annPoint @loc.ppoint

           lhs.substitution = @e.substitution

           lhs.ty = let theta1 = @e.substitution
                        alpha1 = freshVar @loc.num
                        tau2   = @e.ty
                    in Arr (applySubst theta1 alpha1) tau2 @loc.beta'

           lhs.constraints = UnionConstr @e.constraints (@loc.beta' <: @loc.pi)

           e.typeEnvironment = DM.insert @x (Ty $ freshVar @loc.num) @lhs.typeEnvironment

  | App loc.alpha : UNIQUEREF counter
        loc.beta  : UNIQUEREF counter

        loc.beta' = annVar @loc.beta

        loc.alpha'  = freshVar @loc.alpha
        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                           (Arr @e2.ty @loc.alpha' @loc.beta')
        loc.theta = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = applySubst @loc.theta3 @loc.alpha'

        lhs.constraints = UnionConstr (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.constraints)
                                      (applySubst @loc.theta3 @e2.constraints)

        e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Let loc.num : UNIQUEREF counter

        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta  = @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = @e2.ty

        lhs.constraints = UnionConstr (applySubst @loc.theta2 @e1.constraints) @e2.constraints

        e2.typeEnvironment = let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
                                 ty'    = generalise newEnv @e1.ty
                             in  DM.insert @x ty' newEnv

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec 
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = annVar @loc.beta
      loc.pi      = annPoint @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      lhs.constraints = UnionConstr (applySubst @loc.theta1 @e1.constraints)
                                    (applySubst @loc.theta @loc.beta' <: @loc.pi)

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (Ty $ Arr @loc.alpha1' @loc.alpha2' @loc.beta') (
                      DM.insert x (Ty $ @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (Ty $ @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty = Arr (applySubst @loc.theta @alpha1')
                                    (applySubst @loc.theta1 @e1.ty)
                                    (applySubst @loc.theta @loc.beta')
                           ty' = generalise newEnv ty
                       in DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (Ty $ @loc.alpha2') newEnv

  | If loc.theta0 = @c.substitution
       loc.theta1 = @e1.substitution
       loc.theta2 = @e2.substitution
       loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @loc.tau0) Bool
       loc.theta4 = unify (applySubst @loc.theta3 @loc.tau2)
                          (applySubst (@loc.theta3 `dot` @loc.theta2) @loc.tau1)
       loc.theta = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

       loc.tau0 = @c.ty
       loc.tau1 = @e1.ty
       loc.tau2 = @e2.ty

       lhs.ty = applySubst @loc.theta @loc.tau2

       lhs.constraints = 
        let th43  = @loc.theta4 `dot` @loc.theta3
            th432 = th43 `dot` @loc.theta2
            c0 = applySubst (th432 `dot` @loc.theta1) @c.constraints
            c1 = applySubst th432 @e1.constraints
            c2 = applySubst th43 @e1.constraints
        in UnionConstr c0 (UnionConstr c1 c2)

       lhs.substitution = @loc.theta

{
-- | These operators are pretty dull
operatorType :: String -> (Ty,Ty,Ty)
operatorType op | op `elem` ["-","+","*"] = (Nat,Nat,Nat)
                | op `elem` ["==","<",">","<=",">="] = (Nat,Nat,Bool)
                | otherwise = undefined -- kill a warning

-- | Turn a number (the counter's current value) into a type variable. 
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program. 
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, ty') = grabForallVars ts
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      nvars = zipWith (\a b -> TyVar (a ++ b)) forallVars (map show ([0..] :: [Int]))
      s     = foldr (\(o,n) -> Dot (TySub o n)) Identity (zip forallVars nvars)
  in  applySubst s ty'

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], Ty)
grabForallVars (Ty t)          = ([], t)
grabForallVars (Forall tv t1)  = let (vars, ty) = grabForallVars t1
                                 in  (tv:vars, ty)
grabForallVars _               = undefined

-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in a Tm with type lambdas at the right spots.
generalise :: TyEnv -> Ty -> TyScheme
generalise env tau = let free = fv tau DS.\\ fv env
                     in  DS.fold Forall (Ty tau) free

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next 
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. " ++ x ++
                          " wasn't found in the environment.")

annVar :: Int -> SAnn
annVar = AnnVar . ("b" ++) . show 

annPoint :: Int -> SAnn
annPoint = SingleAnn

(<:) :: SAnn -> SAnn -> Constraint
var@(AnnVar _) <: p = SingleConstr var p
_              <: _ = error "invalid constraint"

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

dotApply :: Substitutable t => SimpleSubstitution -> t -> t
dotApply (Dot s1 s2) t = applySubst s1 (applySubst s2 t)
dotApply _           _ = error "not allowed"

-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> SimpleSubstitution

unify Nat Nat   = Identity
unify Bool Bool = Identity

unify (List t _) (List t' _) = unify t t'

unify t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                    | tv1 `DS.notMember` fv t2 = TySub tv1 t2
                                    | tv2 `DS.notMember` fv t1 = TySub tv2 t1
                                    | otherwise = error "Cannot unify. Error."

unify (TyVar tv1) t | tv1 `DS.notMember` fv t = TySub tv1 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify t (TyVar tv2) | tv2 `DS.notMember` fv t = TySub tv2 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify (Arr t11 t12 an1) (Arr t21 t22 an2) =
  let theta0 = AnnSub an2 an1
      theta1 = unify (applySubst theta0 t11) (applySubst theta0 t21)
      theta2 = unify (applySubst (theta1 `dot` theta0) t12) (applySubst (theta1 `dot` theta0) t22)
  in theta2 `dot` theta1 `dot` theta0

unify t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2

-- | A Type environment maps variable names to types.
type TyEnv = Map Var TyScheme


class FreeVariables a where
  fv :: a -> Set String

class FreeAnnVars a where
  fav :: a -> Set SAnn

class Substitutable subject where
  applySubst :: SimpleSubstitution -> subject -> subject

instance Substitutable TyScheme where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t
  applySubst s             (AnnSig _ t) = applySubst s t
  applySubst s@(TySub a _) (Forall tv ts) | a == tv   = Forall tv ts
                                          | otherwise = Forall tv (applySubst s ts)
  applySubst sub (Ty t) = Ty $ applySubst sub t

instance Substitutable Ty where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t

  applySubst (TySub a t0) (TyVar t) 
    | a == t    = t0
    | otherwise = TyVar t

  applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) (applySubst s ann)

  applySubst s (List t ann) = List (applySubst s t) (applySubst s ann)

  applySubst _ Nat  = Nat
  applySubst _ Bool = Bool

instance Substitutable TyEnv where
  applySubst s = DM.map (applySubst s)

instance Substitutable Constraint where
  applySubst Identity    subj = subj
  applySubst d@(Dot _ _) subj = dotApply d subj
  applySubst s (SingleConstr b p)  = SingleConstr (applySubst s b) (applySubst s p)
  applySubst s (UnionConstr c1 c2) = UnionConstr (applySubst s c1) (applySubst s c2)
  applySubst _ c = c

instance Substitutable SAnn where
  applySubst Identity    a = a
  applySubst d@(Dot _ _) a = dotApply d a

  applySubst (AnnSub (AnnVar b) (AnnVar b')) a@(AnnVar b'') 
    | b == b''  = AnnVar b'
    | otherwise = a

  applySubst _ a = a

instance FreeVariables TyScheme where
  fv (Forall v s) = fv s DS.\\ DS.singleton v
  fv (AnnSig _ s) = fv s
  fv (Ty t)       = fv t

instance FreeVariables Ty where
  fv (TyVar tv)      = DS.singleton tv
  fv (Arr t1 t2  _ ) = fv t1 `DS.union` fv t2
  fv (List t1 _)     = fv t1
  fv _               = DS.empty

instance FreeVariables TyEnv where
  fv = DM.fold (\el acc -> fv el `DS.union` acc) DS.empty

instance FreeAnnVars Ty where
  fav (Arr ty1 ty2 ann) = fav ty1 `DS.union` fav ty2 `DS.union` fav ann
  fav (List ty ann)     = fav ty `DS.union` fav ann
  fav _                 = DS.empty

instance FreeAnnVars TyScheme where
  fav (Ty _)       = DS.empty
  fav (Forall _ s) = fav s
  fav (AnnSig t s) = fav s DS.\\ DS.singleton t

instance FreeAnnVars SAnn where
  fav EmptyAnn         = DS.empty
  fav (SingleAnn _)    = DS.empty
  fav (AnnUnion a1 a2) = fav a1 `DS.union` fav a2
  fav av@(AnnVar _)    = DS.singleton av


-- TODO: Add type signatures once the dust has settled
absWl cstr bott join amst evl = iterAbsWl infl join amst evl cstr (mkMap bott)
  where mkMap  s = DM.fromList [(x, s) | SingleConstr x _ <- cstr]
        inflx' k = DM.fromMaybe DS.empty (DM.lookup k (mkMap DS.empty))
        infl     = DM.fromList [ (x, cs)
                               | cxt@(SingleConstr x t) <- cstr
                               , cs <- [ inflx' x' `DS.union` DS.singleton cxt
                                       | x' <- DS.toList $ fav t]]

iterAbsWl _      _    _      _    []                      ana = ana
iterAbsWl inflow join atMost eval (SingleConstr x t:wltl) ana
  | not $ anaLU x `atMost` new = iter newWl ana'
  | otherwise                  = iter wltl  ana
  where new   = eval t ana
        ana'  = ana `join` new
        newWl = wltl ++ DM.fold ((++) . DS.toList) [] inflow -- TODO: Double check
        anaLU = DM.fromJust . flip DM.lookup ana
        iter  = iterAbsWl inflow join atMost eval
}
