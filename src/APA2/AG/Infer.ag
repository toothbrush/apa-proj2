imports
{
import            Control.Monad ()
import            Control.Monad (mplus)
}

ATTR MH
  [ -- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
    annEnvironment  : {AnnEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  |
   -- The algW attribute will contain the type of the term.
    ty                                        : {Ty}
    constraints   USE {`DS.union`} {DS.empty} : {Constraints}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution                              : {SimpleSubstitution}
    lhsTy         USE {`mplus`}    {Nothing}  : {Maybe Ty}
    annotation                                : {SAnn}
    debug         USE {++}         {""}       : {String}
    expressions   USE {++}         {[]}       : {Expressions}
    copy                                      : SELF
  ]

SEM MH
  | CaseBlck
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      -- TODO: Unify types of case (expression) of and the left-hand sides of
      -- the individual case blocks
      -- Then unify the types of the right-hand side of the individual case
      -- blocks

      -- TODO: See if we need some substitutions here...
      loc.theta0 = @ex.substitution
      loc.theta1 = unify @ex.ty (applySubst @loc.theta0 $ fromJust @c1.lhsTy)
      loc.theta2 = trace "theta2" $ unify @ex.ty (applySubst (@loc.theta1 `dot` @loc.theta0) $ fromJust @c2.lhsTy)
      loc.lhsTheta = @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.theta3 = @c1.substitution
      loc.theta4 = @c2.substitution
      -- FIXME: This is where shit is currently hitting the fan
      loc.theta5 = unify (applySubst @loc.lhsTheta @c1.ty)
                         (applySubst (@loc.theta3 `dot` @loc.lhsTheta) @c2.ty)
      loc.theta = @loc.theta5 `dot` @loc.theta4 `dot` @loc.theta3 `dot` @loc.lhsTheta

      loc.ty = applySubst @loc.theta @c1.ty
      lhs.ty = @loc.ty

      lhs.constraints =
        let c1 = @ex.constraints
            c2 = @c1.constraints
            c3 = @c2.constraints
            c4 = (@loc.beta' <:? @c1.annotation) `DS.union`
                 (@loc.beta' <:? @c2.annotation)
            cs = c1 `DS.union` c2 `DS.union` c3 `DS.union` c4
        in applySubst @loc.theta cs


      lhs.substitution = @loc.theta
      lhs.annotation   = @loc.beta'

      c1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      c1.annEnvironment  = applySubst @loc.theta0 @lhs.annEnvironment
      c2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta3) @lhs.typeEnvironment
      c2.annEnvironment  = applySubst (@loc.theta0 `dot` @loc.theta3) @lhs.annEnvironment
  | CaseAlt
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      lhs.constraints = @bnd.constraints

      loc.theta  = @pat.substitution
      loc.ty = applySubst @loc.theta @bnd.ty
      lhs.ty = @loc.ty
      lhs.substitution = @loc.theta

      lhs.annotation = @loc.beta'

      lhs.lhsTy = Just @pat.ty

SEM MH
  | VBool
    loc.beta  : UNIQUEREF counter

    lhs.ty = Bool
    lhs.substitution = Identity
    lhs.constraints  = DS.empty
    lhs.annotation   = mkAnnVar @loc.beta

  | VInt
    loc.beta  : UNIQUEREF counter

    lhs.ty = Nat
    lhs.substitution = Identity
    lhs.constraints  = DS.empty
    lhs.annotation   = mkAnnVar @loc.beta

  | Nil
    loc.alpha : UNIQUEREF counter
    loc.beta  : UNIQUEREF counter
    loc.betaf : UNIQUEREF counter

    loc.alpha' = freshVar @loc.alpha
    loc.beta'  = mkAnnVar @loc.beta
    loc.betaf' = mkAnnVar @loc.betaf

    loc.ty = List @loc.alpha' @loc.beta'

    loc.substitution = Identity

    loc.constraints = DS.empty :: Constraints

    loc.annotation = @loc.betaf'

    lhs.substitution = @loc.substitution
    lhs.ty = @loc.ty
    lhs.constraints = @loc.constraints
    lhs.annotation = @loc.annotation

    lhs.debug = "Nil: \n" ++
                "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                "ty:" ++ show @loc.ty ++ "\n" ++
                "annotation: " ++ show @loc.annotation ++ "\n" ++
                "substitution: " ++ show @loc.substitution ++ "\n" ++
                "constraints: " ++ show @loc.constraints ++ "\n\n"
    
    lhs.expressions = [(@loc.ty,@copy)]

  | Cons
    loc.beta  : UNIQUEREF counter
    loc.betaf : UNIQUEREF counter

    loc.beta'  = mkAnnVar @loc.beta
    loc.betaf' = mkAnnVar @loc.betaf

    loc.listTy = List @e1.ty @e1.annotation
    loc.theta1 = @e1.substitution
    loc.theta2 = @e2.substitution
    loc.theta3 = unify @e2.ty (applySubst @loc.theta2 @loc.listTy)

    loc.substitution  = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

    loc.ty = applySubst @loc.substitution @loc.listTy

    loc.constraints =
      let c1 = @e1.constraints
          c2 = @e2.constraints
          c3 = (@loc.beta' <:? @e1.annotation) `DS.union`
               (@loc.betaf' <:? @e2.annotation)
          cs = c1 `DS.union` c2 `DS.union` c3
      in applySubst @loc.substitution cs 

    loc.annotation = @loc.betaf'

    lhs.substitution = @loc.substitution
    lhs.ty = @loc.ty
    lhs.constraints = @loc.constraints
    lhs.annotation = @loc.annotation

    e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
    e2.annEnvironment  = applySubst @e1.substitution @lhs.annEnvironment

    lhs.debug = "Cons: \n" ++
                "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                "ty:" ++ show @loc.ty ++ "\n" ++
                "annotation: " ++ show @loc.annotation ++ "\n" ++
                "substitution: " ++ show @loc.substitution ++ "\n" ++
                "constraints: " ++ show @loc.constraints ++ "\n\n"
    
    lhs.expressions = [(@loc.ty,@copy)] -- ++ @e1.expressions ++ @e2.expressions

  | Op
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta

      loc.(ty1,ty2,r) = operatorType @op

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty1
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty2
      loc.theta  = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      loc.ty = @loc.r

      loc.substitution = @loc.theta

      loc.constraints = 
        @e1.constraints `DS.union` @e2.constraints `DS.union`
        (@loc.beta' <:? @e1.annotation) `DS.union`
        (@loc.beta' <:? @e2.annotation)

      loc.annotation = @loc.beta'

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation

      e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @loc.theta1 @lhs.annEnvironment

      lhs.expressions = [(@loc.ty,@copy)] ++ @e1.expressions ++ @e2.expressions

      lhs.debug = "Op("++ @op ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

  | Var
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta
      
      loc.phi = fromJust $ DM.lookup @x @lhs.annEnvironment

      loc.(c, ty) = 
        maybe (error ("Variable "++ @x ++" not found in environment (out of scope)."))
              (instantiate @loc.beta)
              (DM.lookup @x @lhs.typeEnvironment)

      -- | If type environment proofs @x to be a function type
      --   we synthesize a new fresh annotation variable. This allows us
      --   to use subeffecting to weaken the annotation whenever deemed necessary without
      --   poisoning the original annotation. (sketchy explanation...)
      loc.annotation = @loc.beta'

      loc.constraints = @loc.beta' <:? @loc.phi

      loc.substitution = Identity

      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.substitution = @loc.substitution

      lhs.expressions = [(@loc.ty,@copy)]

      lhs.debug = "Var("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n"

  | Lambda
      loc.alpha   : UNIQUEREF counter
      loc.ppoint  : UNIQUEREF counter
      loc.betax   : UNIQUEREF counter
      loc.beta    : UNIQUEREF counter

      loc.betax' = mkAnnVar @loc.betax
      loc.beta'  = mkAnnVar @loc.beta

      loc.pi     = mkProgramPoint @x @loc.ppoint
      loc.alpha' = freshVar @loc.alpha

      loc.substitution = @e.substitution

      loc.constraints = @e.constraints `DS.union`
                        (@loc.beta' <:? @loc.pi)

      loc.ty = applySubst @e.substitution (Arr @loc.alpha' @loc.betax' @e.ty @e.annotation)

      loc.annotation = @loc.beta'

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation

      e.typeEnvironment = DM.insert @x (QualSig $ Ty @loc.alpha') @lhs.typeEnvironment
      e.annEnvironment  = DM.insert @x @loc.betax' @lhs.annEnvironment

      lhs.debug = "Lambda("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e.debug

      lhs.expressions = [(@loc.ty,@copy)] ++ @e.expressions


  | App
      loc.alpha  : UNIQUEREF counter
      loc.betar  : UNIQUEREF counter
      loc.betax  : UNIQUEREF counter
      loc.betaf  : UNIQUEREF counter

      loc.betar' = mkAnnVar @loc.betar
      loc.betax' = mkAnnVar @loc.betax
      loc.betaf' = mkAnnVar @loc.betaf
      loc.alpha' = freshVar @loc.alpha

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution

      loc.unify1 = applySubst @loc.theta2 @e1.ty
      loc.unify2 = Arr @e2.ty @loc.betax' @loc.alpha' @loc.betar'
      loc.theta3 = unify @loc.unify1 @unify2

      loc.substitution = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      loc.ty = applySubst @loc.theta3 @loc.alpha'

      loc.annotation = @loc.betaf'

      -- | We do not generate constraints for an application of a 
      --   function to a primitive type.
      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            cs = c1 `DS.union` c2 `DS.union` 
                 (@loc.betax' <:? @e2.annotation) `DS.union`
                 --(@loc.betaf' <:? @e1.annotation) `DS.union` 
                 -- I think this one doesn't make sense, ... 
                 -- all functions that can be the result of @e1 must be included in the result of
                 -- this function application
                 (@loc.betaf' <:? @loc.betar')
        in applySubst @loc.substitution cs

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints

      e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @e1.substitution @lhs.annEnvironment

      lhs.expressions = [(@loc.ty,@copy)] ++ @e1.expressions ++ @e2.expressions

      lhs.debug = "App: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n" ++
                  "unify: " ++ show @loc.unify1 ++ ", " ++ show @loc.unify2 ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

  | Let
      loc.beta : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution

      loc.ty = @e2.ty

      loc.substitution = @loc.theta2 `dot` @loc.theta1

      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = @loc.beta' <:? @e2.annotation
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta2 cs

      loc.annotation = @loc.beta'

      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution

      e2.typeEnvironment =
        let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
            ty'    = snd $ generalise newEnv @e1.annotation @e1.ty @e1.constraints
        in  DM.insert @x ty' newEnv

      e2.annEnvironment = DM.insert @x @e1.annotation @lhs.annEnvironment

      lhs.expressions = [(@loc.ty,@copy)] ++ @e1.expressions ++ @e2.expressions

      lhs.debug = "Let("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec
      loc.alphax : UNIQUEREF counter
      loc.alphar : UNIQUEREF counter
      loc.betax  : UNIQUEREF counter
      loc.betar  : UNIQUEREF counter
      loc.betaf  : UNIQUEREF counter

      loc.alphax' = freshVar @loc.alphax
      loc.alphar' = freshVar @loc.alphar
      loc.betax'  = mkAnnVar @loc.betax
      loc.betar'  = mkAnnVar @loc.betar
      loc.betaf'  = mkAnnVar @loc.betaf

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alphar')
      loc.theta2 = unifyAnn (applySubst @loc.theta1 @e1.annotation) (applySubst @loc.theta1 @loc.betar')
        
      loc.theta  = @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.ty = @e2.ty

      loc.substitution = @loc.theta

      -- | not sure about correctness
      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = applySubst @loc.theta (@loc.betaf' <:? @e2.annotation)
        in c1 `DS.union` c2 `DS.union` c3

      loc.annotation = applySubst @loc.substitution @loc.betaf'

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.annotation = @loc.annotation

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (QualSig . Ty $ Arr @loc.alphax' @loc.betax' @loc.alphar' @loc.betar')
                     (DM.insert x (QualSig $ Ty @loc.alphax') @lhs.typeEnvironment)
                     
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (QualSig $ Ty @loc.alphar') @lhs.typeEnvironment
  
      e1.annEnvironment =
        case @x of
          Just x  -> DM.insert @f @loc.betaf' (DM.insert x @loc.betax' @lhs.annEnvironment)
          Nothing -> DM.insert @f @loc.betaf' @lhs.annEnvironment
          
      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty    = Arr @loc.alphax' @loc.betax' @e1.ty @e1.annotation
                           ty'   = applySubst @loc.theta ty
                           genTy = snd $ generalise newEnv @e1.annotation ty' @e1.constraints
                       in  DM.insert @f genTy newEnv
            Nothing -> DM.insert @f (QualSig $ Ty @loc.alphar') newEnv -- not sure about this

      e2.annEnvironment =
        let apps t = applySubst @loc.theta (DM.insert @f @e1.annotation t)
        in case @x of
             Just x' -> apps (DM.insert x' @loc.betax' @lhs.annEnvironment)
             Nothing -> apps @lhs.annEnvironment

      lhs.debug = "LetRec("++ @f ++ show @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

  | If
      loc.beta   : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta

      loc.theta0 = @c.substitution
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @c.ty) Bool

      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.ty)

      loc.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.ty = applySubst @loc.substitution @e2.ty

      loc.constraints =
        let c  = (@loc.beta' <:? @e1.annotation) `DS.union`
                 (@loc.beta' <:? @e2.annotation)
            cs = @e1.constraints `DS.union` @e2.constraints `DS.union` c
        in applySubst @loc.substitution cs

      loc.annotation = @loc.beta'

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.annotation = @loc.annotation

      e1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      e1.annEnvironment  = applySubst @loc.theta0 @lhs.annEnvironment
      e2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.typeEnvironment
      e2.annEnvironment  = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.annEnvironment

      lhs.expressions = [(@loc.ty,@copy)] ++ @c.expressions ++ @e1.expressions ++ @e2.expressions

      lhs.debug = "If: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @c.debug ++ @e1.debug ++ @e2.debug

{
freshVar :: Int -> Ty
freshVar i = TyVar $ 'τ' : show i

mkAnnVar :: Int -> SAnn
mkAnnVar i = AnnVar $ 'β' : show i

mkProgramPoint :: Var -> Int -> SAnn
mkProgramPoint v p = AnnSet (DS.singleton (v ++ show p))

refreshAnnVars :: Int -> Ty -> Ty
refreshAnnVars seed ty = applySubst (listToSimpleSubst annSubs) ty
  where
  fresh   prefix = map (\x -> prefix : show seed ++ show x) ([0..] :: [Int])
  annSubs        = zipWith (\a b -> AnnSub a (AnnVar b)) (toList $ fav ty) (fresh 'β')

listToSimpleSubst :: [SimpleSubstitution] -> SimpleSubstitution
listToSimpleSubst = foldr Dot Identity

forallTySubst :: TyVar -> SimpleSubstitution -> (Ty -> Ty) -> SimpleSubstitution
forallTySubst tyvar s@(TySub tv t) f | tv == tyvar = trace "refresh" TySub tv (f t)
                                     | otherwise   = s
forallTySubst tyvar (Dot s s') f = Dot (forallTySubst tyvar s f) (forallTySubst tyvar s' f)
forallTySubst _ s _ = s

operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-", "+", "*"]              = (Nat, Nat, Nat)
  | op `elem` ["==", "<", ">", "<=", ">="] = (Nat, Nat, Bool)
  | otherwise                              = error $ "Invalid op: " ++ op

(<:?) :: SAnn -> SAnn -> Constraints
_           <:? AnnEmpty = DS.empty
AnnVar beta <:? phi      = DS.singleton (Constraint (AnnVar beta) phi)
_           <:? _        = error "only variables allowed"

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

generalise :: TyEnv -> SAnn -> Ty -> Constraints -> (Constraints, TyScheme)
generalise env ann tau c = let free      = ftv tau DS.\\ ftv env
                               genTyVars = DS.fold Forall (QualSig $ Ty tau) free
                           in (undefined, genTyVars)

{-
generalise :: TyEnv -> SAnn -> Ty -> Constraints -> (Constraints, TyScheme)
generalise env ann tau c = 
  let (c', c'')       = simplify env tau c
      freeTyVars      = ftv tau DS.\\ ftv env
      activeAnnVars   = fav tau DS.\\ fav env DS.\\ fav ann

      pseudoActiveAnnVars = fav c' DS.\\ activeAnnVars

      qualifiedType = let o x (QualSig x') = QualSig $ Qual x x'
                          o _ xs           = xs
                      in DS.fold o (QualSig $ Ty tau) c'

      quantifyTyVars  = DS.fold Forall qualifiedType freeTyVars
      quantifyAnnVars = DS.fold AnnSig quantifyTyVars activeAnnVars

  in (c'', quantifyAnnVars)
-}

instantiate :: Int -> TyScheme -> (Constraints, Ty)
instantiate seed ts = (undefined, applySubst subst ty)
  where (Binders tyvars annvars cs ty) = collectBinders ts
        fresh   prefix = map (\x -> prefix : show seed ++ show x) ([0..] :: [Int])
        tySubs         = zipWith (\a b -> TySub a (TyVar b)) tyvars (fresh 'τ')
        annSubs        = []
        subst          = foldr Dot Identity (tySubs ++ annSubs)

{-
instantiate :: Int -> TyScheme -> (Constraints, Ty)
instantiate seed ts = (applySubst subst cs, applySubst subst ty)
  where (Binders tyvars annvars cs ty) = collectBinders ts
        fresh   prefix = map (\x -> prefix : show seed ++ show x) ([0..] :: [Int])
        tySubs         = zipWith (\a b -> TySub a (TyVar b)) tyvars (fresh 'τ')
        annSubs        = zipWith (\x y -> AnnSub x (AnnVar y)) annvars (fresh 'β')
        subst          = foldr Dot Identity (tySubs ++ annSubs)
-}

}
