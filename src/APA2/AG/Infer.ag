optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Set as DS
}

ATTR MH
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {TySubst}
    constraints  : {Constraints}
  ]

SEM MH
  | VBool lhs.ty = Bool
          lhs.substitution = Identity
          lhs.constraints = emptyConstraint

  | VInt  lhs.ty = Nat
          lhs.substitution = Identity
          lhs.constraints = emptyConstraint

  | Nil   loc.num : UNIQUEREF counter

          lhs.ty = List (TyVar $ show @loc.num) emptyAnn

          lhs.substitution = Identity

          lhs.constraints = emptyConstraint

  | Cons  lhs.ty = let tau1   = @e1.ty
                       theta1 = @e1.substitution
                       tau2   = @e2.ty
                       theta2 = @e2.substitution
                       theta3 = unify tau2 (applySubst theta2 (List tau1 emptyAnn))
                       theta  = theta3 `dot` theta2 `dot` theta1
                   in applySubst theta (List tau1 emptyAnn)

          lhs.constraints = emptyConstraint

          e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Var loc.num : UNIQUEREF counter

        lhs.ty = if @x `DM.member` @lhs.typeEnvironment
                     then instantiate $ getVar @x @lhs.typeEnvironment
                     else error ("Variable "++ @x ++" not found in environment (out of scope).")

        lhs.constraints = emptyConstraint

        lhs.substitution = Identity

  | Lambda loc.num     : UNIQUEREF counter
           loc.ppoint  : UNIQUEREF counter

           lhs.substitution = @e.substitution

           lhs.ty = let theta1 = @e.substitution
                        alpha1 = freshVar @loc.num
                        tau2   = @e.ty
                    in Arr (applySubst theta1 alpha1) tau2 emptyAnn -- TODO: Ann

           lhs.constraints = emptyConstraint

           e.typeEnvironment = DM.insert @x (Ty $ freshVar @loc.num) @lhs.typeEnvironment

  | App loc.num : UNIQUEREF counter

        lhs.substitution = let theta1 = @e1.substitution
                               theta2 = @e2.substitution
                               theta3 = unify (applySubst theta2 @e1.ty)
                                              (Arr (@e2.ty) (freshVar @loc.num) emptyAnn) -- TODO Ann
                           in  theta3 `dot` theta2 `dot` theta1

        lhs.ty = let alpha1 = freshVar @loc.num
                     theta2 = @e2.substitution
                     theta3 = unify (applySubst theta2 @e1.ty)
                                    (Arr (@e2.ty) alpha1 emptyAnn) -- TODO Ann
                 in  applySubst theta3 alpha1

        lhs.constraints = emptyConstraint

        e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Let loc.num : UNIQUEREF counter

        lhs.substitution = let theta1 = @e1.substitution
                               theta2 = @e2.substitution
                           in  theta2 `dot` theta1

        lhs.ty = @e2.ty

        lhs.constraints = emptyConstraint

        e2.typeEnvironment = let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
                                 ty'    = generalise newEnv @e1.ty
                             in  DM.insert @x ty' newEnv

  | If loc.theta0 = @c.substitution
       loc.theta1 = @e1.substitution
       loc.theta2 = @e2.substitution
       loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @loc.tau0) Bool
       loc.theta4 = unify (applySubst @loc.theta3 @loc.tau2) 
                          (applySubst (@loc.theta3 `dot` @loc.theta2) @loc.tau1)
       loc.theta = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

       loc.tau0 = @c.ty
       loc.tau1 = @e1.ty
       loc.tau2 = @e2.ty

       lhs.ty = applySubst @loc.theta @loc.tau2

       lhs.constraints = emptyConstraint

       lhs.substitution = @loc.theta

{
emptyAnn :: SAnn
emptyAnn = AnnSet DS.empty

-- | Turn a number (the counter's current value) into a type variable. 
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program. 
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, ty') = grabForallVars ts
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      nvars = zipWith (\a b -> TyVar (a ++ b)) forallVars (map show ([0..] :: [Int]))
      s = foldr (\(o,n) -> Dot (Sub o n)) Identity (zip forallVars nvars)
  in  applySubst s ty'

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], Ty)
grabForallVars (Ty t)          =  ([], t)
grabForallVars (Forall tv t1)  =  let (vars, ty) = grabForallVars t1
                                  in  (tv:vars, ty)

-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in an Tm with type lambdas at the right spots.
generalise :: TyEnv -> Ty -> TyScheme
generalise env tau = let free = ftv tau DS.\\ ftv env -- Set ftv
                     in  DS.fold Forall (Ty tau) free

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next 
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. " ++ x ++
                          " wasn't found in the environment.")

-- | A Type environment maps variable names to types.
type TyEnv = Map Var TyScheme
-- | TyVar and Var are just strings (variable names).

-- | A type substitution. Used for substitution of type variables
-- in signatures.
data TySubst = Identity -- ^ Identity substitution, do nothing. 
             | Sub TyVar Ty -- ^ Substitute a type variable with a type. 
             | Dot TySubst TySubst -- ^ Chain substitutions together.
             deriving Show

type Constraints = DS.Set Constraint
data Constraint = Constraint AnnVar Point
  deriving Show

emptyConstraint :: Set Constraint
emptyConstraint = DS.singleton (Constraint "nothing" 0)

dot :: TySubst -> TySubst -> TySubst
dot = Dot

-- | A class which is useful for defining functions such as 'applySubst' (which
-- substitutes all occurences of a variable with a type, and 'ftv' which returns
-- all the free type variables in the argument.
class Types a where
    applySubst :: TySubst -> a -> a
    ftv        :: a -> Set Var

instance Types TyScheme where
  applySubst Identity t = t
  applySubst s@(Sub a _) (Forall tv ts) | a == tv   = Forall tv ts
                                        | otherwise = Forall tv (applySubst s ts)
  applySubst (Dot s1 s2) t  = applySubst s1 (applySubst s2 t)
  applySubst sub (Ty t)  = Ty $ applySubst sub t

  ftv (Forall v s)  = ftv s DS.\\ DS.singleton v
  ftv (Ty t)        = ftv t

instance Types Ty where
    -- The free type variables are accumulated in the same way
    -- as recommended in the course slides.
    ftv (TyVar tv)                  = DS.singleton tv
    ftv (Arr t1 t2 ann)             = ftv t1 `DS.union` ftv t2
    ftv Nat                         = DS.empty
    ftv Bool                        = DS.empty
    ftv (List t1 _)                 = ftv t1
    -- The implementation of applySubst is exactly like presented in the
    -- slides of this course.
    applySubst Identity t           = t
    applySubst (Dot s1 s2) t        = applySubst s1 (applySubst s2 t)

    applySubst (Sub a t0) (TyVar t) | a == t    = t0
                                    | otherwise = TyVar t

    applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) ann

    applySubst s (List t ann) = List (applySubst s t) ann

    applySubst _ Nat  = Nat
    applySubst _ Bool = Bool

instance Types TyEnv where
    -- Simply extend the functions to support lists
    -- of whatever they already support.
    applySubst s  = DM.map (applySubst s)
    ftv           = DM.fold (\el acc -> ftv el `DS.union` acc) DS.empty


-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> TySubst

unify Nat Nat = Identity

unify Bool Bool = Identity

unify (List t _) (List t' _) = unify t t'

unify t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                    | tv1 `DS.notMember` ftv t2 = Sub tv1 t2
                                    | tv2 `DS.notMember` ftv t1 = Sub tv2 t1
                                    | otherwise = error "Cannot unify. Error."

unify (TyVar tv1) t | tv1 `DS.notMember` ftv t = Sub tv1 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify t (TyVar tv2) | tv2 `DS.notMember` ftv t = Sub tv2 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify (Arr t11 t12 an1) (Arr t21 t22 an2) =
  let theta1 = unify t11 t21
      theta2 = unify (applySubst theta1 t12) (applySubst theta1 t22)
  in theta2 `dot` theta1

unify t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2
}
