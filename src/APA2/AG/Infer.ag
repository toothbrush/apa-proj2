optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import Debug.Trace
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Map as Map
import qualified  Data.Maybe as DM
import            Data.MultiSet (MultiSet)
import qualified  Data.MultiSet as DMS
import qualified  Data.Set as DS
}

ATTR MH
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    constraints  : {Constraint}
  ]

SEM MH
  | VBool lhs.ty = Bool
          lhs.substitution = Identity
          lhs.constraints = EmptyConstr

  | VInt  lhs.ty = Nat
          lhs.substitution = Identity
          lhs.constraints = EmptyConstr

  | Nil   loc.num : UNIQUEREF counter

          lhs.ty = List (TyVar $ show @loc.num) (AnnVar "g")

          lhs.substitution = Identity

          lhs.constraints = EmptyConstr

  | Cons  lhs.ty = let tau1   = @e1.ty
                       theta1 = @e1.substitution
                       tau2   = @e2.ty
                       theta2 = @e2.substitution
                       theta3 = unify tau2 (applySubst theta2 (List tau1 (AnnVar "g")))
                       theta  = theta3 `dot` theta2 `dot` theta1
                   in applySubst theta (List tau1 (AnnVar "g"))

          lhs.constraints = EmptyConstr

          e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Op    loc.alpha1 : UNIQUEREF counter
          loc.alpha2 : UNIQUEREF counter

          loc.alpha1' = freshVar @loc.alpha1
          loc.alpha2' = freshVar @loc.alpha2

          loc.(ty,ty',r) = operatorType @op

          loc.theta1 = @e1.substitution
          loc.theta2 = @e2.substitution
          loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
          loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'

          lhs.ty = @loc.r

          lhs.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

          lhs.constraints = let th43 = @loc.theta4 `dot` @loc.theta3
                            in  UnionConstr (applySubst (th43 `dot` @loc.theta2) @e1.constraints)
                                            (applySubst th43 @e2.constraints)

          e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment

  | Var loc.num : UNIQUEREF counter

        lhs.ty = if @x `DM.member` @lhs.typeEnvironment
                     then instantiate $ getVar @x @lhs.typeEnvironment
                     else error ("Variable "++ @x ++" not found in environment (out of scope).")

        lhs.constraints = EmptyConstr

        lhs.substitution = Identity

  | Lambda loc.num     : UNIQUEREF counter
           loc.ppoint  : UNIQUEREF counter
           loc.beta    : UNIQUEREF counter

           loc.beta' = annVar @loc.beta
           loc.pi    = annPoint @loc.ppoint

           lhs.substitution = @e.substitution

           lhs.ty = let theta1 = @e.substitution
                        alpha1 = freshVar @loc.num
                        tau2   = @e.ty
                    in Arr (applySubst theta1 alpha1) tau2 @loc.beta'

           lhs.constraints = UnionConstr @e.constraints (@loc.beta' <: @loc.pi)

           e.typeEnvironment = DM.insert @x (Ty $ freshVar @loc.num) @lhs.typeEnvironment

  | App loc.alpha : UNIQUEREF counter
        loc.beta  : UNIQUEREF counter

        loc.beta' = annVar @loc.beta

        loc.alpha'  = freshVar @loc.alpha
        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                           (Arr @e2.ty @loc.alpha' @loc.beta')
        loc.theta = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = applySubst @loc.theta3 @loc.alpha'

        lhs.constraints = UnionConstr (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.constraints)
                                      (applySubst @loc.theta3 @e2.constraints)

        e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Let loc.num : UNIQUEREF counter

        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta  = @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = @e2.ty

        lhs.constraints = UnionConstr (applySubst @loc.theta2 @e1.constraints) @e2.constraints

        e2.typeEnvironment = let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
                                 ty'    = generalise newEnv @e1.ty
                             in  DM.insert @x ty' newEnv

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec 
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = annVar @loc.beta
      loc.pi      = annPoint @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      lhs.constraints = UnionConstr (applySubst @loc.theta1 @e1.constraints)
                                    (applySubst @loc.theta @loc.beta' <: @loc.pi)

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (Ty $ Arr @loc.alpha1' @loc.alpha2' @loc.beta') (
                      DM.insert x (Ty $ @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (Ty $ @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty = Arr (applySubst @loc.theta @alpha1')
                                    (applySubst @loc.theta1 @e1.ty)
                                    (applySubst @loc.theta @loc.beta')
                           ty' = generalise newEnv ty
                       in DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (Ty $ @loc.alpha2') newEnv

  | If loc.theta0 = @c.substitution
       loc.theta1 = @e1.substitution
       loc.theta2 = @e2.substitution
       loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @loc.tau0) Bool
       loc.theta4 = unify (applySubst @loc.theta3 @loc.tau2)
                          (applySubst (@loc.theta3 `dot` @loc.theta2) @loc.tau1)
       loc.theta = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

       loc.tau0 = @c.ty
       loc.tau1 = @e1.ty
       loc.tau2 = @e2.ty

       lhs.ty = applySubst @loc.theta @loc.tau2

       lhs.constraints = 
        let th43  = @loc.theta4 `dot` @loc.theta3
            th432 = th43 `dot` @loc.theta2
            c0 = applySubst (th432 `dot` @loc.theta1) @c.constraints
            c1 = applySubst th432 @e1.constraints
            c2 = applySubst th43 @e1.constraints
        in UnionConstr c0 (UnionConstr c1 c2)

       lhs.substitution = @loc.theta

{
-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in a Tm with type lambdas at the right spots.
generalise :: TyEnv -> Ty -> TyScheme
generalise env tau = let free      = fv tau DS.\\ fv env
                         genTyVars = DS.fold Forall (Ty tau) free
                         annots    = fav tau -- TODO: exclude anything?
                     in  {- trace (show annots) $ -}
                         DS.fold AnnSig genTyVars annots

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, forallAVars, ty') = grabForallVars ts
      sfold c = foldr (\(o,n) -> Dot (c o n)) Identity
      nzip  c = zipWith (\a b -> c (a ++ b)) forallVars (map show ([0..] :: [Int]))
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      s  = sfold TySub (zip forallVars $ nzip TyVar)
      -- do kinda the same for annotation variables. 
      s' = sfold AnnSub (zip (map AnnVar forallAVars) $ nzip AnnVar)
  in  {-trace (show finalSub) $ -}
      applySubst (Dot s s') ty'

-- | These operators are pretty dull
operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-","+","*"]            = (Nat, Nat, Nat)
  | op `elem` ["==","<",">","<=",">="] = (Nat, Nat, Bool)
  | otherwise                          = error $ "Invalid op: " ++ op

-- | Turn a number (the counter's current value) into a type variable.
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program.
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], [AnnVar], Ty)
grabForallVars (Ty t)          = ([], [], t)
grabForallVars (Forall tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (tv:vars, avars, ty)
-- now with Annotation super powers
grabForallVars (AnnSig tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (vars, tv:avars, ty)

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. " ++ x ++
                          " wasn't found in the environment.")

annVar :: Int -> SAnn
annVar = AnnVar . ("b" ++) . show 

annPoint :: Int -> SAnn
annPoint = SingleAnn

(<:) :: SAnn -> SAnn -> Constraint
var@(AnnVar _) <: p = SingleConstr $ ConstrPair var p
_              <: _ = error "invalid constraint"

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

dotApply :: Substitutable t => SimpleSubstitution -> t -> t
dotApply (Dot s1 s2) t = applySubst s1 (applySubst s2 t)
dotApply _           _ = error "not allowed"

-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> SimpleSubstitution

unify Nat Nat   = Identity
unify Bool Bool = Identity

unify (List t _) (List t' _) = unify t t'

unify t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                    | tv1 `DS.notMember` fv t2 = TySub tv1 t2
                                    | tv2 `DS.notMember` fv t1 = TySub tv2 t1
                                    | otherwise = error "Cannot unify. Error."

unify (TyVar tv1) t | tv1 `DS.notMember` fv t = TySub tv1 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify t (TyVar tv2) | tv2 `DS.notMember` fv t = TySub tv2 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify (Arr t11 t12 an1) (Arr t21 t22 an2) =
  let theta0 = AnnSub an2 an1
      theta1 = unify (applySubst theta0 t11) 
                     (applySubst theta0 t21)
      theta2 = unify (applySubst (theta1 `dot` theta0) t12) 
                     (applySubst (theta1 `dot` theta0) t22)
  in theta2 `dot` theta1 `dot` theta0

unify t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2


-- TODO: Double-check correctness of implementation
absWl :: Set ConstrPair -> a -> (a -> a -> a) -> (a -> a -> Bool)
      -> (SAnn -> Map SAnn a -> a) -> Map SAnn a
absWl cstr bott join amst eval = iterAbsWl infl join amst eval
                                           (DMS.fromSet cstr) (mkMap bott)
  where mkMap  s = let mf (ConstrPair x _) xs = DM.insert x s xs
                   in  DS.fold mf DM.empty cstr
        inflx' k = DM.fromMaybe DS.empty (DM.lookup k (mkMap DS.empty))
        infl     = DS.fold (\x xs -> inflx_ x `DM.union` xs) DM.empty cstr
        inflx_ cxt@(ConstrPair _ t) =
          let cf x' m = DM.singleton x' (DS.singleton cxt `DS.union` inflx' x') `DM.union` m
          in  DS.fold cf DM.empty (DS.map AnnVar $ fav t)

iterAbsWl :: Map SAnn (Set ConstrPair) -> (a -> a -> a) -> (a -> a -> Bool)
          -> (SAnn -> Map SAnn a -> a) -> MultiSet ConstrPair -> Map SAnn a
          -> Map SAnn a
iterAbsWl infl join atMost eval wlst ana
  | DMS.null wlst            = ana
  | not $ anaLU `atMost` new = iter (wltl `DMS.union` inflx x) newAna
  | otherwise                = iter wltl ana
  where new   = eval t ana
        inflx = DMS.fromSet . DM.fromJust . flip DM.lookup infl
        anaLU = DM.fromJust $ DM.lookup x ana
        newAna  = DM.insert x newAnax ana
        newAnax = anaLU `join` new
        iter  = iterAbsWl infl join atMost eval
        wltl  = DMS.delete cp wlst
        cp@(ConstrPair x t) = DMS.findMin wlst

class Substitutable subject where
  applySubst :: SimpleSubstitution -> subject -> subject

instance Substitutable TyScheme where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t
  applySubst s             (AnnSig _ t) = applySubst s t
  applySubst s@(TySub a _) (Forall tv ts) | a == tv   = Forall tv ts
                                          | otherwise = Forall tv (applySubst s ts)
  applySubst sub (Ty t) = Ty $ applySubst sub t

instance Substitutable Ty where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t

  applySubst (TySub a t0) (TyVar t)
    | a == t    = t0
    | otherwise = TyVar t

  applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) (applySubst s ann)

  applySubst s (List t ann) = List (applySubst s t) (applySubst s ann)

  applySubst _ Nat  = Nat
  applySubst _ Bool = Bool

instance Substitutable TyEnv where
  applySubst s = DM.map (applySubst s)

instance Substitutable Constraint where
  applySubst Identity    subj = subj
  applySubst d@(Dot _ _) subj = dotApply d subj
  applySubst s (SingleConstr (ConstrPair b p))  = SingleConstr $ ConstrPair (applySubst s b) (applySubst s p)
  applySubst s (UnionConstr c1 c2) = UnionConstr (applySubst s c1) (applySubst s c2)
  applySubst _ c = c

instance Substitutable SAnn where
  applySubst Identity    a = a
  applySubst d@(Dot _ _) a = dotApply d a

  applySubst (AnnSub (AnnVar b) (AnnVar b')) a@(AnnVar b'') 
    | b == b''  = AnnVar b'
    | otherwise = a

  applySubst _ a = a


class FreeVariables a where
  fv :: a -> Set TyVar -- alias String

class FreeAnnVars a where
  fav :: a -> Set AnnVar -- alias String

instance FreeVariables TyScheme where
  fv x = fv_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeVariables Ty where
  fv x = fv_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeVariables TyEnv where
-- TODO: Move to AG once uuagc bugs are fixed
  fv = DM.fold (\el acc -> fv el `DS.union` acc) DS.empty

instance FreeAnnVars Ty where
  fav x = fav_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeAnnVars TyScheme where
  fav x = fav_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeAnnVars SAnn where
  fav x = fav_Syn_SAnn (wrap_SAnn (sem_SAnn x) Inh_SAnn)

type TyEnv = Map Var TyScheme
}

ATTR TyScheme Ty -- TyEnv
  [|| fv  USE {`DS.union`} {DS.empty} : {Set TyVar}   -- alias String
  ]

ATTR TyScheme Ty SAnn
  [|| fav USE {`DS.union`} {DS.empty} : {Set AnnVar} -- alias String
  ]

SEM TyScheme
  | AnnSig lhs.fav = @ts.fav DS.\\ DS.singleton @a
  | Forall lhs.fv  = @ts.fv  DS.\\ DS.singleton @a

SEM Ty
  | TyVar lhs.fv = DS.singleton @a

SEM SAnn
  | AnnVar lhs.fav = DS.singleton @var

{- SEM TyEnv-}
{-   | Entry lhs.fv = @val.fv `DS.union` @tl.fv-}
{-   | Nil   lhs.fv = DS.empty-}

ATTR Constraint ConstrPair SAnn
  [||copy : SELF]

ATTR Constraint
  [|| mkCstrSet USE {`DS.union`} {DS.empty} : {Set ConstrPair}
  ]

SEM Constraint
  | SingleConstr lhs.mkCstrSet = DS.singleton @pr.copy
