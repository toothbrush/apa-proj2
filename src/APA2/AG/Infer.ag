optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import Debug.Trace
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Map as Map
import qualified  Data.Map as Data.Map
import            Data.MultiSet (MultiSet)
import qualified  Data.MultiSet as DMS
import qualified  Data.Set as DS
import            Data.Maybe
}

ATTR MH Cases
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
    annEnvironment  : {AnnEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    constraints  : {Constraints}
    annotation   : {Maybe SAnn}
    debug        USE {++} {""} : {String}
  ]


-- TODO: Verify that this implementation is correct
SEM Cases
  | Nil  loc.alpha : UNIQUEREF counter
         lhs.annotation   = Nothing
         lhs.constraints  = DS.empty
         lhs.substitution = Identity
         lhs.ty           = freshVar @loc.alpha

SEM MH
  | VBool 
    lhs.ty = Bool
    lhs.substitution = Identity
    lhs.constraints = DS.empty
    lhs.annotation = Nothing

  | VInt  
    lhs.ty = Nat
    lhs.substitution = Identity
    lhs.constraints = DS.empty
    lhs.annotation = Nothing

  | Nil   
    loc.alpha : UNIQUEREF counter
    loc.beta : UNIQUEREF counter 

    loc.alpha' = freshVar @loc.alpha         
    loc.beta' = mkAnnVar @loc.beta

    lhs.ty = List @loc.alpha' @loc.beta'

    lhs.substitution = Identity

    lhs.constraints = DS.empty

    lhs.annotation = Just (AnnVar @loc.beta')

  | Cons  
    loc.beta : UNIQUEREF counter 

    loc.beta' = mkAnnVar @loc.beta

    loc.listTy = List @e1.ty @loc.beta'
    loc.theta1 = @e1.substitution
    loc.theta2 = @e2.substitution
    loc.theta3 = unify @e2.ty (applySubst @loc.theta2 @loc.listTy)
    loc.theta  = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

    lhs.ty = applySubst @loc.theta @loc.listTy

    lhs.constraints = 
      let c1 = @e1.constraints
          c2 = @e2.constraints
          c3 = (@loc.beta' <:? @e1.annotation) `DS.union`
               (@loc.beta' <:? @e2.annotation)
          cs = c1 `DS.union` c2 `DS.union` c3
      in applySubst @loc.theta cs 
    
    lhs.annotation = Just (AnnVar @loc.beta')

    e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
    e2.annEnvironment = applySubst @e1.substitution @lhs.annEnvironment

  | Op    
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta

      loc.(ty,ty',r) = operatorType @op

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'
      loc.theta  = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      lhs.ty = @loc.r

      lhs.substitution = @loc.theta

      lhs.constraints = 
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = (@loc.beta' <:? @e1.annotation) `DS.union`
                 (@loc.beta' <:? @e2.annotation)
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta cs

      e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @loc.theta1 @lhs.annEnvironment

      lhs.annotation = Just (AnnVar @loc.beta')

  | Var 
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      loc.ty =
        if @x `DM.member` @lhs.typeEnvironment
          then let x  = getVar @x @lhs.typeEnvironment 
                   x' = instantiate @loc.beta x 
               in case x' of
                    Arr a b _ -> Arr a b @loc.beta'
                    _         -> x'
          else error ("Variable "++ @x ++" not found in environment (out of scope).")

      loc.constraints = 
        let phi = @x ? @lhs.annEnvironment 
        in @loc.beta' <:? phi

      loc.annotation = 
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      loc.substitution = Identity

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation
      lhs.substitution = @loc.substitution
  
      lhs.debug = "Var("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n"

  | Lambda 
      loc.alpha   : UNIQUEREF counter
      loc.ppoint  : UNIQUEREF counter
      loc.beta    : UNIQUEREF counter
      loc.beta1   : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.beta'' = mkAnnVar @loc.beta1
      loc.pi     = mkProgramPoint @x @loc.ppoint
      loc.alpha' = freshVar @loc.alpha

      loc.substitution = @e.substitution
      loc.constraints = @e.constraints `DS.union` (@loc.beta' <:? (Just @loc.pi))
      loc.ty = applySubst @e.substitution (Arr @loc.alpha' @e.ty @loc.beta')
      loc.annotation = Just (AnnVar @loc.beta')
  
      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation

      e.typeEnvironment = DM.insert @x (Ty @loc.alpha') @lhs.typeEnvironment
      e.annEnvironment  = DM.insert @x Nothing @lhs.annEnvironment

      lhs.debug = "Lambda("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e.debug


  | App 
      loc.alpha : UNIQUEREF counter
      loc.beta  : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      loc.alpha' = freshVar @loc.alpha
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                         (Arr @e2.ty @loc.alpha' @loc.beta')

      loc.substitution = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      loc.ty = applySubst @loc.theta3 @loc.alpha'

      loc.annotation = 
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      -- | We do not generate constraints for an application of a 
      --   function to a primitive type.
      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = case @e2.ty of
                  Arr _ _ _ -> @loc.beta' <:? @e1.annotation
                  _         -> DS.empty
            c4 = @loc.beta' <:? @e2.annotation
            cs = c1 `DS.union` c2 `DS.union` c3 `DS.union` c4
        in applySubst @loc.substitution cs

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints

      e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @e1.substitution @lhs.annEnvironment

      lhs.debug = "App: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug


  | Let 
      loc.beta : UNIQUEREF counter
        
      loc.beta'  = mkAnnVar @loc.beta
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution

      loc.ty = @e2.ty

      loc.substitution = @loc.theta2 `dot` @loc.theta1

      loc.constraints = 
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = @loc.beta' <:? @e2.annotation
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta2 cs
      
      loc.annotation = 
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution
      
      e2.typeEnvironment = 
        let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
            ty'    = snd $ generalise newEnv @e1.ty @e1.constraints
        in DM.insert @x ty' newEnv

      e2.annEnvironment = DM.insert @x @e1.annotation @lhs.annEnvironment

      lhs.debug = "Let("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec 
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter
      loc.beta1  : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta
      loc.beta''  = mkAnnVar @loc.beta1
      loc.pi      = mkProgramPoint @f @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      -- | not sure about correctness
      lhs.constraints = 
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = applySubst @loc.theta (@loc.beta' <:? @e2.annotation)
        in c1 `DS.union` c2 `DS.union` c3

      lhs.annotation = Just (AnnVar @loc.beta'')

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (Ty $ Arr @loc.alpha1' @loc.alpha2' @loc.beta') (
                      DM.insert x (Ty $ @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (Ty $ @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty = Arr (applySubst @loc.theta @alpha1')
                                    (applySubst @loc.theta1 @e1.ty)
                                    (applySubst @loc.theta @loc.beta')
                           ty' = snd $ generalise newEnv ty @e1.constraints
                       in DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (Ty $ @loc.alpha2') newEnv

      e2.annEnvironment = 
        case @x of 
          Just x  -> applySubst @e1.substitution 
                                (DM.insert @f (Just (AnnVar @loc.beta')) (DM.insert x @e1.annotation @lhs.annEnvironment))
          Nothing -> applySubst @e1.substitution
                                (DM.insert @f (Just (AnnVar @loc.beta')) @lhs.annEnvironment)

  | If 
      loc.beta   : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.theta0 = @c.substitution
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @c.ty) Bool
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty)
                         (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.ty)

      loc.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.ty = 
        case @e2.ty of
          Arr a b _ -> applySubst @loc.substitution (Arr a b @loc.beta')
          _         -> @e2.ty

      loc.constraints = 
        let c  = (@loc.beta' <:? @e1.annotation) `DS.union`
                 (@loc.beta' <:? @e2.annotation)
            cs = @e1.constraints `DS.union` @e2.constraints `DS.union` c
        in applySubst @loc.substitution cs

      loc.annotation = 
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.annotation = @loc.annotation

      e1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      e1.annEnvironment  = applySubst @loc.theta0 @lhs.annEnvironment
      e2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.typeEnvironment                          
      e2.annEnvironment  = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.annEnvironment

      lhs.debug = "If: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @c.debug ++ @e1.debug ++ @e2.debug


{
generalise :: TyEnv -> Ty -> Constraints -> (Constraints, TyScheme)
generalise env tau c = let free      = fv tau DS.\\ fv env
                           genTyVars = DS.fold Forall (Ty tau) free
                       in (undefined, genTyVars)

-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in a Tm with type lambdas at the right spots.
{-
generalise :: TyEnv -> Ty -> Constraints -> (Constraints, TyScheme) -- I'm assuming there's no need for Annotations here?
generalise env     tau c = let (c', c'')   = simplify env tau c
                               freeAlpha   = fv  tau DS.\\ fv  env
                               freeBeta'   = fav c'   -- ??? DS.\\ fav env -- onzin? : DS.\\ fav tau -- DS.\\ fav ann
                               genTyVars   = DS.fold Forall (Ty tau) freeAlpha
                               --genAnnVars  = DS.fold Forall (genTyVars) (freeBeta `DS.union` freeBeta')
                           in  {- trace (show annots) $ -}
                               (c'', DS.fold AnnSig genTyVars (freeBeta'))
-}

-- | Simplify constraints. 
-- Seems reasonable.
{-
simplify :: TyEnv -> Ty -> Constraints -> (Constraints, Constraints)
simplify env tau c = let active = pseudoActive (DS.map AnnVar ({- fav env `DS.union` -} fav tau)) c
                         ranges = trace ("active vars: "++show active++"\n") $ range c
                         theta  = satisfiable active ranges
                         c'     = applySubst theta c
                     in  partition env c'

pseudoActive :: Set SAnn -> Constraints -> Set AnnVar
pseudoActive active c =
  let extrAnn (Constraint l u) xs | l `DS.member` active = DS.insert u xs
                                  | otherwise            = xs
      vars = DS.fold extrAnn DS.empty c `DS.union` active
  in  if DS.null (vars `DS.intersection` active)
        then pseudoActive vars c
        else let extrVar (AnnVar x) xs = DS.insert x xs
                 extrVar _          xs = xs
             in DS.fold extrVar DS.empty vars

range :: Constraints -> Map AnnVar SAnn
range = worklist

satisfiable :: Set AnnVar -> Map AnnVar SAnn -> SimpleSubstitution
--satisfiable is incorrect: this is still the security analysis version! no range here!
satisfiable active analysis =
  let act'          = DS.map AnnVar active
      ana'          = DM.mapKeys AnnVar analysis
      func beta l
        | l <= beta = if beta `DS.notMember` act' || l == beta
                        then AnnSub beta l
                        else Identity
        | otherwise = error "lower bound is larger than upper bound"
      substLst      = DM.mapWithKey func ana'
  in DM.fold Dot Identity substLst

--partition :: TyEnv -> Constraints -> ( , )
partition env cs = (cs,DS.empty)
-}
{- for this we need (instance (FreeAnnVars TyEnv)), but that doesn't make sense, right?
                   let active = DS.map AnnVar $ fav env
                       prop   = DS.fromList [ Constraint l u | Constraint l u <- cs, l `DS.member` active || u `DS.member` active ]
                       qual   = DS.fromList [ pi | pi <- cs, pi `DS.notMember` prop]
                   in  (prop, qual)
                   -}

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], [AnnVar], Ty)
grabForallVars (Ty t)          = ([], [], t)
grabForallVars (Forall tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (tv:vars, avars, ty)
-- now with Annotation super powers
grabForallVars (AnnSig tv t1)  = let (vars, avars, ty) = grabForallVars t1
                                 in  (vars, tv:avars, ty)

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: Int -> TyScheme -> Ty
instantiate seed ts =
  let (faVars, forallAVars, ty') = grabForallVars ts
      sfold c = foldr (\(o,n) -> Dot (c o n)) Identity
      seed' = show seed
      nzip  c = zipWith (\_ b -> {- trace ("fresh="++a++b++"\n") $ -} c (seed' ++ b)) faVars (map show ([0..] :: [Int]))
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      s  = sfold TySub (zip faVars $ nzip TyVar)
      -- TODO: do kinda the same for annotation variables.
  in  {-trace (show finalSub) $ -}
      applySubst s ty'

{-
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, forallAVars, ty') = grabForallVars ts
      sfold c = foldr (\(o,n) -> Dot (c o n)) Identity
      nzip  c = zipWith (\a b -> c (a ++ b)) forallVars (map show ([0..] :: [Int]))
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      s  = sfold TySub (zip forallVars $ nzip TyVar)
      -- do kinda the same for annotation variables.
      s' = sfold AnnSub (zip (map AnnVar forallAVars) $ nzip AnnVar)
  in  {-trace (show finalSub) $ -}
      applySubst (Dot s s') ty'
-}

-- | These operators are pretty dull
operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-", "+", "*"]              = (Nat, Nat, Nat)
  | op `elem` ["==", "<", ">", "<=", ">="] = (Nat, Nat, Bool)
  | otherwise                              = error $ "Invalid op: " ++ op

-- | Turn a number (the counter's current value) into a type variable.
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program.
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

mkAnnVar :: Int -> AnnVar
mkAnnVar i = "b" ++ show i

mkProgramPoint :: Var -> Int -> SAnn
mkProgramPoint v p = AnnSet (DS.singleton (v ++ (show p))) 

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. '" ++ x ++
                          "'\nwasn't found in the environment.")

(<:?) :: AnnVar -> Maybe SAnn -> Constraints
beta <:? Just phi = DS.singleton (constrain beta phi)
_    <:? _        = DS.empty

-- | B superset phi
constrain :: AnnVar -> SAnn -> Constraint
constrain beta phi = Constraint beta phi

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

dotApply :: Substitutable t => SimpleSubstitution -> t -> t
dotApply (Dot s1 s2) t = applySubst s1 (applySubst s2 t)
dotApply _           _ = error "not allowed"

-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> SimpleSubstitution
unify ty ty' = 
  trace ("Unify(" ++ show ty ++ ", " ++ show ty' ++ ")") 
        unify' ty ty'
 
unify' Nat  Nat  = Identity
unify' Bool Bool = Identity

unify' (List t an) (List t' an') = let theta1 = unify t t'
                                       theta2 = unifyAnn (applySubst theta1 an) (applySubst theta1 an')
                                   in theta2 `dot` theta1

unify' t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                     | tv1 `DS.notMember` fv t2 = TySub tv1 t2
                                     | tv2 `DS.notMember` fv t1 = TySub tv2 t1
                                     | otherwise = error "Cannot unify. Error."

unify' (TyVar tv1) t | tv1 `DS.notMember` fv t = TySub tv1 t
                     | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify' t (TyVar tv2) | tv2 `DS.notMember` fv t = TySub tv2 t
                     | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify' (Arr t11 t12 an) (Arr t21 t22 an') =
  let theta1 = unify t11 t21
      theta2 = unify (applySubst theta1 t12)
                     (applySubst theta1 t22)
      theta3 = let th21 = theta2 `dot` theta1
               in unifyAnn (applySubst th21 an) (applySubst th21 an')
  in theta3 `dot` theta2 `dot` theta1

unify' t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2

unifyAnn :: AnnVar -> AnnVar -> SimpleSubstitution
unifyAnn v v'
  | v == v'   = Identity
  | otherwise = AnnSub v' v 

(?) :: Ord a => a -> Map a b -> b
a ? m = fromJust $ DM.lookup a m 

partitionConstraints :: Constraints -> (Constraints, Constraints)
partitionConstraints cs = DS.fold o (DS.empty, DS.empty) cs
  where o c@(Constraint _ (AnnVar _)) (cs,cs') = (cs, DS.insert c cs')
        o c@(Constraint _ (AnnSet _)) (cs,cs') = (DS.insert c cs, cs')  

worklist :: Constraints -> Map AnnVar SAnn
worklist cs = 
  let
    (solved,unsolved) = partitionConstraints cs
   
    (w, analysis, infl) = 
      let o c@(Constraint a (AnnVar b)) (w, analysis, infl) = ( DMS.insert c w
                                                              , DM.insert a AnnEmpty analysis
                                                              , DM.insert a DS.empty (DM.insert b DS.empty infl))
          o c@(Constraint a (AnnSet b)) (w, analysis, infl) = ( w
                                                              , DM.insert a AnnEmpty analysis
                                                              , DM.insert a DS.empty infl)
      in DS.fold o (DMS.empty, DM.empty, DM.empty) cs

    analysis' = 
      let o c@(Constraint x x'@(AnnSet _)) a = DM.update (\v -> Just (v ∪ x')) x a
      in DS.fold o analysis solved

    infl' = 
      let o c@(Constraint _ (AnnVar x)) infl = DM.update (Just . DS.insert c) x infl 
      in DS.fold o infl unsolved

    solveConstraints w analysis 
      | DMS.null w = analysis
      | otherwise  = let (w', analysis') = trace (debugStep w analysis) (step infl' w analysis)
                     in solveConstraints w' analysis'
    
  in trace ("INFL: " ++ show infl' ++ "\n") solveConstraints w analysis'


step infl w analysis 
  | DMS.null w  = (w, analysis)
  | otherwise   = 
    let ((Constraint x (AnnVar t)), w') = let c = DMS.findMin w
                                          in (c, DMS.delete c w)
        
        value    = x ? analysis
        newValue = t ? analysis
    in if value ⊈ newValue
        then let analysis'  = DM.insert t (value ∪ newValue) analysis
                 successors = DMS.fromSet (x ? infl)
                 augmentedW = successors `DMS.union` w'
             in trace ("insert new") (augmentedW, analysis')
        else (w', analysis)

(⊆) :: SAnn -> SAnn -> Bool
AnnEmpty ⊆ AnnEmpty = True
AnnEmpty ⊆ (AnnSet a) 
  | DS.null a = True
  | otherwise = False
(AnnSet a) ⊆ (AnnSet b) = DS.isSubsetOf a b
_ ⊆ _  = error "no variables allowed"

(⊈) :: SAnn -> SAnn -> Bool
a ⊈ b = not (a ⊆ b)

(∪) :: SAnn -> SAnn -> SAnn
AnnEmpty ∪ a = a
a ∪ AnnEmpty = a
(AnnSet a) ∪ (AnnSet b) = AnnSet (DS.union a b) 
_ ∪ _ = error "no variables allowed" 

{-
step :: Influence
     -> EvalFunc
     -> Worklist
     -> Analysis
     -> (Worklist, Analysis)
step infl eval w ana
  | DMS.null w              = (w, ana)
  | not $ xInAna `pord` new = trace "do body" body
  | otherwise               = (w', ana)
  where
  (Constraint (AnnVar v) t, w') = let c = DMS.findMin w
                                  in (c, DMS.delete c w)
  new    = eval t ana  
  xInAna = v ? ana
  
  body = let newAna = DM.insert v (xInAna `join` new) ana
             w''    = DS.fold o w' (v ? infl)
             o c@(Constraint (AnnVar _) _) = DMS.insert c
             o _                           = id
         in (w'', newAna)
-}
{-
worklist :: Constraints -> (SAnn -> Map AnnVar SAnn -> SAnn) -> Map AnnVar SAnn
worklist constraints eval = trace ("INFL: " ++ show infl' ++ "\n") repeatStep w analysis'
  where
  (w, analysis, infl) = DS.fold o (DMS.empty, DM.empty, DM.empty) constraints 
    where o c@(Constraint (AnnVar b) _) (w, ana, infl) = (DMS.insert c w
                                                         ,DM.insert b (bottom :: SAnn) ana
                                                         ,DM.insert b DS.empty infl
                                                         )
  analysis' = DS.fold o analysis constraints
    where o c@(Constraint _ t) r = DS.fold (\x -> DM.insert x (bottom :: SAnn)) r (fav t)

  infl' = DS.fold o infl constraints
    where o c@(Constraint (AnnVar v) x) infl = DM.update (Just . DS.insert c) v infl

  repeatStep w ana 
    | DMS.null w = ana
    | otherwise  = let (w', ana') = trace (debugStep w ana)
                                          step infl' eval w ana
                   in repeatStep w' ana'
-}
debugStep w ana = 
  "step: " ++ "\n" ++ 
  "W: " ++ show w ++ "\n" ++
  "ANA: " ++ show ana ++ "\n"

class Substitutable subject where
  applySubst :: SimpleSubstitution -> subject -> subject

-- TODO: check whether bound variables are not being substituted
instance Substitutable TyScheme where
  applySubst Identity     t = t
  applySubst d@(Dot _ _) t  = dotApply d t

  applySubst s (Ty t) = Ty (applySubst s t)

  applySubst s@(TySub a _) t@(Forall tv ts) | a == tv   = t
                                            | otherwise = Forall tv (applySubst s ts)

  applySubst s@(AnnSub a _) t@(AnnSig tv ts) | a == tv   = t
                                             | otherwise = AnnSig tv (applySubst s ts)
  
  applySubst _ t = t

instance Substitutable Ty where
  applySubst Identity       t             = t
  applySubst d@(Dot _ _)    t             = dotApply d t

  applySubst (TySub a t0) (TyVar t)
    | a == t    = t0
    | otherwise = TyVar t

  applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) (applySubst s ann)

  applySubst s (List t ann) = List (applySubst s t) (applySubst s ann)

  applySubst _ Nat  = Nat
  applySubst _ Bool = Bool
  applySubst _ t    = t

instance Substitutable TyEnv where
  applySubst s = DM.map (applySubst s)

instance Substitutable AnnEnv where
  applySubst s = DM.map (maybe Nothing (Just . applySubst s))

instance Substitutable AnnVar where
  applySubst s@(AnnSub a b) a'
    | a == a'   = b
    | otherwise = a'
  applySubst _ a = a

instance Substitutable Constraint where
  applySubst Identity    cs     = cs
  applySubst d@(Dot _ _) cs     = dotApply d cs
  applySubst s@(AnnSub a b) (Constraint a' b')
    | a == a'   = Constraint b (applySubst s b')
    | otherwise = Constraint a' (applySubst s b')
  applySubst _ c = c

instance Substitutable Constraints where
  applySubst s = DS.map (applySubst s)

instance Substitutable SAnn where
  applySubst Identity    a            = a
  applySubst d@(Dot _ _) a@(AnnVar _) = dotApply d a

  applySubst (AnnSub b b') a@(AnnVar b'')
    | b == b''  = AnnVar b'
    | otherwise = a

  applySubst _ a = a

class FreeVariables a where
  fv :: a -> Set TyVar -- alias String

class FreeAnnVars a where
  fav :: a -> Set AnnVar -- alias String

instance FreeVariables TyScheme where
  fv x = fv_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeVariables Ty where
  fv x = fv_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeVariables TyEnv where
  fv x = fv_Syn_TyEnv (wrap_TyEnv (sem_TyEnv x) Inh_TyEnv)

instance FreeAnnVars Ty where
  fav x = fav_Syn_Ty (wrap_Ty (sem_Ty x) Inh_Ty)

instance FreeAnnVars TyScheme where
  fav x = fav_Syn_TyScheme (wrap_TyScheme (sem_TyScheme x) Inh_TyScheme)

instance FreeAnnVars SAnn where
  fav (AnnVar v)       = DS.singleton v
  fav _                = DS.empty

instance FreeAnnVars Constraints where
  fav = DS.fold DS.union DS.empty . DS.map fav

instance FreeAnnVars Constraint where
  fav c = fav_Syn_Constraint (wrap_Constraint (sem_Constraint c) Inh_Constraint)
}

TYPE TyEnv = MAP {Var} TyScheme

TYPE AnnEnv = MAP {Var} {Maybe SAnn}

ATTR TyScheme Ty TyEnv
  [|| fv  USE {`DS.union`} {DS.empty} : {Set TyVar}   -- alias String
  ]

ATTR TyScheme Ty Constraint SAnn
  [|| fav USE {`DS.union`} {DS.empty} : {Set AnnVar} -- alias String
  ]

SEM TyScheme
  | AnnSig lhs.fav = @ts.fav DS.\\ DS.singleton @a
  | Forall lhs.fv  = @ts.fv  DS.\\ DS.singleton @a

SEM Ty
  | TyVar lhs.fv = DS.singleton @a

SEM TyEnv
  | Entry lhs.fv = @val.fv `DS.union` @tl.fv
  | Nil   lhs.fv = DS.empty

SEM SAnn
  | AnnVar lhs.fav = DS.singleton @var
