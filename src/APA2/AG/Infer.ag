imports
{
import            Control.Monad ()
}

ATTR MH
  [ -- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
    annEnvironment  : {AnnEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  |
   -- The algW attribute will contain the type of the term.
    ty : {Ty}
    constraints USE {`DS.union`} {DS.empty} : {Constraints}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    lhsTy USE {`mplus`} {Nothing} : {Maybe Ty}
    annotation   : {Maybe SAnn}
    debug        USE {++} {""} : {String}
  ]

SEM MH
  | CaseBlck
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      -- TODO: Unify types of case (expression) of and the left-hand sides of
      -- the individual case blocks
      -- Then unify the types of the right-hand side of the individual case
      -- blocks

      -- TODO: See if we need some substitutions here...
      loc.theta0 = @ex.substitution
      loc.theta1 = unify @ex.ty (applySubst @loc.theta0 $ fromJust @c1.lhsTy)
      loc.theta2 = trace "theta2" $ unify @ex.ty (applySubst (@loc.theta1 `dot` @loc.theta0) $ fromJust @c2.lhsTy)
      loc.lhsTheta = @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.theta3 = @c1.substitution
      loc.theta4 = @c2.substitution
      -- FIXME: This is where shit is currently hitting the fan
      loc.theta5 = unify (applySubst @loc.lhsTheta @c1.ty)
                         (applySubst (@loc.theta3 `dot` @loc.lhsTheta) @c2.ty)
      loc.theta = @loc.theta5 `dot` @loc.theta4 `dot` @loc.theta3 `dot` @loc.lhsTheta

      loc.ty = applySubst @loc.theta @c1.ty
      lhs.ty = @loc.ty

      lhs.constraints =
        let c1 = @ex.constraints
            c2 = @c1.constraints
            c3 = @c2.constraints
            c4 = (@loc.beta' <:? @c1.annotation) `DS.union`
                 (@loc.beta' <:? @c2.annotation)
            cs = c1 `DS.union` c2 `DS.union` c3 `DS.union` c4
        in applySubst @loc.theta cs


      lhs.substitution = @loc.theta
      lhs.annotation   =
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      c1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      c1.annEnvironment  = applySubst @loc.theta0 @lhs.annEnvironment
      c2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta3) @lhs.typeEnvironment
      c2.annEnvironment  = applySubst (@loc.theta0 `dot` @loc.theta3) @lhs.annEnvironment
  | CaseAlt
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      lhs.constraints = @bnd.constraints

      loc.theta  = @pat.substitution
      loc.ty = applySubst @loc.theta @bnd.ty
      lhs.ty = @loc.ty
      lhs.substitution = @loc.theta

      lhs.annotation = 
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      lhs.lhsTy = Just @pat.ty

SEM MH
  | VBool
    lhs.ty = Bool
    lhs.substitution = Identity
    lhs.constraints  = DS.empty
    lhs.annotation   = Nothing

  | VInt
    lhs.ty = Nat
    lhs.substitution = Identity
    lhs.constraints  = DS.empty
    lhs.annotation   = Nothing

  | Nil
    loc.alpha : UNIQUEREF counter
    loc.beta  : UNIQUEREF counter

    loc.alpha' = freshVar @loc.alpha
    loc.beta' = mkAnnVar @loc.beta

    lhs.ty = List @loc.alpha' @loc.beta'

    lhs.substitution = Identity

    lhs.constraints = DS.empty

    lhs.annotation = Just (AnnVar @loc.beta')

  | Cons
    loc.beta : UNIQUEREF counter

    loc.beta' = mkAnnVar @loc.beta

    loc.listTy = List @e1.ty @loc.beta'
    loc.theta1 = @e1.substitution
    loc.theta2 = @e2.substitution
    loc.theta3 = unify @e2.ty (applySubst @loc.theta2 @loc.listTy)
    loc.theta  = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

    lhs.ty = applySubst @loc.theta @loc.listTy

    lhs.constraints =
      let c1 = @e1.constraints
          c2 = @e2.constraints
          c3 = (@loc.beta' <:? @e1.annotation) `DS.union`
               (@loc.beta' <:? @e2.annotation)
          cs = c1 `DS.union` c2 `DS.union` c3
      in applySubst @loc.theta cs 

    lhs.annotation = Just (AnnVar @loc.beta')

    e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
    e2.annEnvironment  = applySubst @e1.substitution @lhs.annEnvironment

  | Op
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta

      loc.(ty,ty',r) = operatorType @op

      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty) @loc.ty
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty) @loc.ty'
      loc.theta  = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      lhs.ty = @loc.r

      lhs.substitution = @loc.theta

      lhs.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = (@loc.beta' <:? @e1.annotation) `DS.union`
                 (@loc.beta' <:? @e2.annotation)
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta cs

      e2.typeEnvironment = applySubst @loc.theta1 @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @loc.theta1 @lhs.annEnvironment

      lhs.annotation = Just (AnnVar @loc.beta')

  | Var
      loc.beta : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      loc.phi = @x ? @lhs.annEnvironment

      loc.(c, ty) = 
        maybe (error ("Variable "++ @x ++" not found in environment (out of scope)."))
              (instantiate @loc.beta)
              (DM.lookup @x @lhs.typeEnvironment)

      -- this does not work for a case like: let f = \x -> true in let g = \k -> if f 0 then k else \y -> false in g f
      loc.constraints = @loc.c `DS.union` (@loc.beta' <:? @loc.phi)

      loc.annotation =
        case @loc.ty of
          Arr _ _ a -> Just (AnnVar a)
          _         -> Nothing

      loc.substitution = Identity

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation
      lhs.substitution = @loc.substitution

      lhs.debug = "Var("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n"

  | Lambda
      loc.alpha   : UNIQUEREF counter
      loc.ppoint  : UNIQUEREF counter
      loc.beta    : UNIQUEREF counter
      loc.beta1   : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.beta'' = mkAnnVar @loc.beta1
      loc.pi     = mkProgramPoint @x @loc.ppoint
      loc.alpha' = freshVar @loc.alpha

      loc.substitution = @e.substitution
      loc.constraints = @e.constraints `DS.union` (@loc.beta' <:? (Just @loc.pi))
      loc.ty = applySubst @e.substitution (Arr @loc.alpha' @e.ty @loc.beta')
      loc.annotation = Just (AnnVar @loc.beta')

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.annotation = @loc.annotation

      e.typeEnvironment = DM.insert @x (QualSig $ Ty @loc.alpha') @lhs.typeEnvironment
      e.annEnvironment  = DM.insert @x Nothing @lhs.annEnvironment

      lhs.debug = "Lambda("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e.debug


  | App
      loc.alpha : UNIQUEREF counter
      loc.beta  : UNIQUEREF counter

      loc.beta' = mkAnnVar @loc.beta

      loc.alpha' = freshVar @loc.alpha
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                         (Arr @e2.ty @loc.alpha' @loc.beta')

      loc.substitution = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

      loc.ty = applySubst @loc.theta3 @loc.alpha'

      loc.annotation =
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      -- | We do not generate constraints for an application of a 
      --   function to a primitive type.
      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = case @e2.ty of
                  Arr _ _ _ -> @loc.beta' <:? @e1.annotation
                  _         -> DS.empty
            c4 = @loc.beta' <:? @e2.annotation
            cs = c1 `DS.union` c2 `DS.union` c3 `DS.union` c4
        in applySubst @loc.substitution cs

      lhs.substitution = @loc.substitution
      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints

      e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment
      e2.annEnvironment  = applySubst @e1.substitution @lhs.annEnvironment

      lhs.debug = "App: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug


  | Let
      loc.beta : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution

      loc.ty = @e2.ty

      loc.substitution = @loc.theta2 `dot` @loc.theta1

      loc.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = @loc.beta' <:? @e2.annotation
            cs = c1 `DS.union` c2 `DS.union` c3
        in applySubst @loc.theta2 cs

      loc.annotation =
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      lhs.ty = @loc.ty
      lhs.annotation = @loc.annotation
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution

      e2.typeEnvironment =
        let newEnv  = applySubst @e1.substitution @lhs.typeEnvironment
            gen ann = snd $ generalise newEnv ann @e1.ty @e1.constraints
            ty'     = maybe (QualSig $ Ty @e1.ty) gen @e1.annotation
        in  DM.insert @x ty' newEnv

      e2.annEnvironment = DM.insert @x @e1.annotation @lhs.annEnvironment

      lhs.debug = "Let("++ @x ++ "): \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @e1.debug ++ @e2.debug

-- what about the cfa for let loop = loop in loop, loop :: a does not have the capability to carry annotations
-- but is can be passed into a function..
  | LetRec
      loc.alpha1 : UNIQUEREF counter
      loc.alpha2 : UNIQUEREF counter
      loc.ppoint : UNIQUEREF counter
      loc.beta   : UNIQUEREF counter
      loc.beta1  : UNIQUEREF counter

      loc.alpha1' = freshVar @loc.alpha1
      loc.alpha2' = freshVar @loc.alpha2
      loc.beta'   = mkAnnVar @loc.beta
      loc.beta''  = mkAnnVar @loc.beta1
      loc.pi      = mkProgramPoint @f @loc.ppoint

      loc.theta0 = @e1.substitution
      loc.theta1 = unify @e1.ty (applySubst @loc.theta0 @loc.alpha2')
      loc.theta  = @loc.theta1 `dot` @loc.theta0

      lhs.ty = @e2.ty

      lhs.substitution = @loc.theta

      -- | not sure about correctness
      lhs.constraints =
        let c1 = @e1.constraints
            c2 = @e2.constraints
            c3 = applySubst @loc.theta (@loc.beta' <:? @e2.annotation)
        in c1 `DS.union` c2 `DS.union` c3

      loc.annotation = Just (AnnVar @loc.beta'')
      lhs.annotation = @loc.annotation

      e1.typeEnvironment =
        case @x of
          Just x  -> DM.insert @f (QualSig . Ty $ Arr @loc.alpha1' @loc.alpha2' @loc.beta') (
                      DM.insert x (QualSig $ Ty @loc.alpha1') @lhs.typeEnvironment
                     )
          -- A recursive let binding without arguments, e.g. let loop = loop in loop
          Nothing -> DM.insert @f (QualSig $ Ty @loc.alpha2') @lhs.typeEnvironment

      e2.typeEnvironment =
        let newEnv = applySubst @loc.theta0 @lhs.typeEnvironment
        in case @x of
            Just _  -> let ty      = Arr (applySubst @loc.theta @alpha1')
                                         (applySubst @loc.theta1 @e1.ty)
                                         (applySubst @loc.theta @loc.beta')
                           gen ann = snd $ generalise newEnv ann ty @e1.constraints
                           ty'     = maybe (QualSig $ Ty ty) gen @loc.annotation
                       in  DM.insert @f ty' newEnv
            Nothing -> DM.insert @f (QualSig $ Ty @loc.alpha2') newEnv

      e2.annEnvironment =
        let apps t = applySubst @e1.substitution (DM.insert @f (Just (AnnVar @loc.beta')) t)
        in case @x of
             Just x' -> apps (DM.insert x' @e1.annotation @lhs.annEnvironment)
             Nothing -> apps @lhs.annEnvironment

  | If
      loc.beta   : UNIQUEREF counter

      loc.beta'  = mkAnnVar @loc.beta
      loc.theta0 = @c.substitution
      loc.theta1 = @e1.substitution
      loc.theta2 = @e2.substitution
      loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @c.ty) Bool
      loc.theta4 = unify (applySubst @loc.theta3 @e2.ty)
                         (applySubst (@loc.theta3 `dot` @loc.theta2) @e1.ty)

      loc.substitution = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

      loc.ty = 
        case @e2.ty of
          Arr a b _ -> applySubst @loc.substitution (Arr a b @loc.beta')
          _         -> @e2.ty

      loc.constraints =
        let c  = (@loc.beta' <:? @e1.annotation) `DS.union`
                 (@loc.beta' <:? @e2.annotation)
            cs = @e1.constraints `DS.union` @e2.constraints `DS.union` c
        in applySubst @loc.substitution cs

      loc.annotation =
        case @loc.ty of
          Arr _ _ _ -> Just (AnnVar @loc.beta')
          _         -> Nothing

      lhs.ty = @loc.ty
      lhs.constraints = @loc.constraints
      lhs.substitution = @loc.substitution
      lhs.annotation = @loc.annotation

      e1.typeEnvironment = applySubst @loc.theta0 @lhs.typeEnvironment
      e1.annEnvironment  = applySubst @loc.theta0 @lhs.annEnvironment
      e2.typeEnvironment = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.typeEnvironment
      e2.annEnvironment  = applySubst (@loc.theta0 `dot` @loc.theta1) @lhs.annEnvironment

      lhs.debug = "If: \n" ++
                  "tyEnv: " ++ show @lhs.typeEnvironment ++ "\n" ++
                  "annEnv: " ++ show @lhs.annEnvironment ++ "\n" ++
                  "ty:" ++ show @loc.ty ++ "\n" ++
                  "annotation: " ++ show @loc.annotation ++ "\n" ++
                  "substitution: " ++ show @loc.substitution ++ "\n" ++
                  "constraints: " ++ show @loc.constraints ++ "\n\n" ++
                  @c.debug ++ @e1.debug ++ @e2.debug

{
freshVar :: Int -> Ty
freshVar i = TyVar $ 'τ' : show i

mkAnnVar :: Int -> AnnVar
mkAnnVar i = 'β' : show i

mkProgramPoint :: Var -> Int -> SAnn
mkProgramPoint v p = AnnSet (DS.singleton (v ++ show p))

operatorType :: String -> (Ty, Ty, Ty)
operatorType op
  | op `elem` ["-", "+", "*"]              = (Nat, Nat, Nat)
  | op `elem` ["==", "<", ">", "<=", ">="] = (Nat, Nat, Bool)
  | otherwise                              = error $ "Invalid op: " ++ op

(<:?) :: AnnVar -> Maybe SAnn -> Constraints
beta <:? Just phi = DS.singleton (Constraint beta phi)
_    <:? _        = DS.empty

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

generalise :: TyEnv -> SAnn -> Ty -> Constraints -> (Constraints, TyScheme)
generalise env ann tau c =
  let ftvs   = ftv tau DS.\\ ftv env
      favs   = fav tau DS.\\ fav env DS.\\ fav ann
      fcvs   = fav c DS.\\ favs
      (c', c'') = simplify env tau c
      qtdCs  = let fld x (QualSig x') = QualSig $ Qual x x'
                   fld _ xs           = xs
               in  DS.fold fld (QualSig $ Ty tau) c'
      qtdTVs = DS.fold Forall qtdCs ftvs
      qtdAVs = DS.fold AnnSig qtdTVs (favs `DS.union` fcvs)
  in  (c'', qtdAVs)

instantiate :: Int -> TyScheme -> (Constraints, Ty)
instantiate seed ts = (applySubst subst cs, applySubst subst ty)
  where (Binders tyvars annvars cs ty) = collectBinders ts
        fresh   pfx = map (\x -> pfx : show seed ++ show x) ([0..] :: [Int])
        tySubs      = zipWith (\a b -> TySub a (TyVar b)) tyvars (fresh 'τ')
        annSubs     = zipWith AnnSub annvars (fresh 'β')
        subst       = foldr Dot Identity (tySubs ++ annSubs)

}
