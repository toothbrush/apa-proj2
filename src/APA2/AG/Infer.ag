optpragmas {
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import            Data.Map (Map)
import qualified  Data.Map as DM
import qualified  Data.Maybe as DM
import            Data.Set (Set)
import qualified  Data.Set as DS
}

ATTR MH
  [-- The type environment should start empty, then grow as more lambdas
    -- etc. are encountered.
    typeEnvironment : {TyEnv}
  | -- The counter is used to generate fresh variable names, which are unique.
    counter : {Int}
  | -- The algW attribute will contain the type of the term.
    ty : {Ty}
    -- The substitution attribute will contain the needed substitutions 
    -- of the type environment.
    substitution : {SimpleSubstitution}
    constraints  : {Constraints}
  ]

SEM MH
  | VBool lhs.ty = Bool
          lhs.substitution = Identity
          lhs.constraints = emptyConstraint

  | VInt  lhs.ty = Nat
          lhs.substitution = Identity
          lhs.constraints = emptyConstraint

  | Nil   loc.num : UNIQUEREF counter

          lhs.ty = List (TyVar $ show @loc.num) (AnnVar "g")

          lhs.substitution = Identity

          lhs.constraints = emptyConstraint

  | Cons  lhs.ty = let tau1   = @e1.ty
                       theta1 = @e1.substitution
                       tau2   = @e2.ty
                       theta2 = @e2.substitution
                       theta3 = unify tau2 (applySubst theta2 (List tau1 (AnnVar "g")))
                       theta  = theta3 `dot` theta2 `dot` theta1
                   in applySubst theta (List tau1 (AnnVar "g"))

          lhs.constraints = emptyConstraint

          e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Var loc.num : UNIQUEREF counter

        lhs.ty = if @x `DM.member` @lhs.typeEnvironment
                     then instantiate $ getVar @x @lhs.typeEnvironment
                     else error ("Variable "++ @x ++" not found in environment (out of scope).")

        lhs.constraints = emptyConstraint

        lhs.substitution = Identity

  | Lambda loc.num     : UNIQUEREF counter
           loc.ppoint  : UNIQUEREF counter
           loc.beta    : UNIQUEREF counter

           loc.beta' = annVar @loc.beta
           loc.pi    = annPoint @loc.ppoint

           lhs.substitution = @e.substitution

           lhs.ty = let theta1 = @e.substitution
                        alpha1 = freshVar @loc.num
                        tau2   = @e.ty
                    in Arr (applySubst theta1 alpha1) tau2 @loc.beta'

           lhs.constraints = @e.constraints `DS.union` (DS.singleton $ @loc.beta' <: @loc.pi)

           e.typeEnvironment = DM.insert @x (Ty $ freshVar @loc.num) @lhs.typeEnvironment

  | App loc.num  : UNIQUEREF counter
        loc.beta : UNIQUEREF counter

        loc.beta' = annVar @loc.beta

        loc.alpha  = freshVar @loc.num
        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta3 = unify (applySubst @loc.theta2 @e1.ty)
                           (Arr (@e2.ty) @loc.alpha @loc.beta')
        loc.theta = @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = applySubst @loc.theta3 @loc.alpha

        lhs.constraints = applySubst (@loc.theta3 `dot` @loc.theta2) @e1.constraints `DS.union`
                          applySubst @loc.theta3 @e2.constraints

        e2.typeEnvironment = applySubst @e1.substitution @lhs.typeEnvironment

  | Let loc.num : UNIQUEREF counter

        loc.theta1 = @e1.substitution
        loc.theta2 = @e2.substitution
        loc.theta  = @loc.theta2 `dot` @loc.theta1

        lhs.substitution = @loc.theta

        lhs.ty = @e2.ty

        lhs.constraints = (applySubst @loc.theta2 @e1.constraints) `DS.union` @e2.constraints

        e2.typeEnvironment = let newEnv = applySubst @e1.substitution @lhs.typeEnvironment
                                 ty'    = generalise newEnv @e1.ty
                             in  DM.insert @x ty' newEnv

  | If loc.theta0 = @c.substitution
       loc.theta1 = @e1.substitution
       loc.theta2 = @e2.substitution
       loc.theta3 = unify (applySubst (@loc.theta2 `dot` @loc.theta1) @loc.tau0) Bool
       loc.theta4 = unify (applySubst @loc.theta3 @loc.tau2)
                          (applySubst (@loc.theta3 `dot` @loc.theta2) @loc.tau1)
       loc.theta = @loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1 `dot` @loc.theta0

       loc.tau0 = @c.ty
       loc.tau1 = @e1.ty
       loc.tau2 = @e2.ty

       lhs.ty = applySubst @loc.theta @loc.tau2

       lhs.constraints = 
        let c0 = applySubst (@loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2 `dot` @loc.theta1) @c.constraints
            c1 = applySubst (@loc.theta4 `dot` @loc.theta3 `dot` @loc.theta2) @e1.constraints
            c2 = applySubst (@loc.theta4 `dot` @loc.theta3) @e1.constraints
        in c0 `DS.union` c1 `DS.union` c2

       lhs.substitution = @loc.theta

{
-- | Turn a number (the counter's current value) into a type variable. 
-- NOTE: This assumes the user doesn't use variables like v[0-9]+ in the program. 
--       This seems reasonable, given the scope of the assignment, a workaround
--       shouldn't be difficult to implement.
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : show i

-- | Instantiate. Specialise a given polymorphic type
-- with fresh variables. A coercion function is also returned, 
-- which should be used to show where in the original term
-- type instantiations were applied.
instantiate :: TyScheme -> Ty
instantiate ts =
  let (forallVars, ty') = grabForallVars ts
      -- first get all "forall" bound variables,
      -- then replace these with fresh variables
      nvars = zipWith (\a b -> TyVar (a ++ b)) forallVars (map show ([0..] :: [Int]))
      s = foldr (\(o,n) -> Dot (TySub o n)) Identity (zip forallVars nvars)
  in  applySubst s ty'

-- | Unrolls a type, and returns all the variables
-- which are in "forall". This is useful for instantiation,
-- since these variables will need concrete values.
grabForallVars :: TyScheme -> ([TyVar], Ty)
grabForallVars (Ty t)          =  ([], t)
grabForallVars (Forall tv t1)  =  let (vars, ty) = grabForallVars t1
                                  in  (tv:vars, ty)

-- | Generalise function. Finds all unbound type variables in
-- a type T, and then makes the type into 
-- "foreach [those variables] T."
-- Also returns a coercion. This is to be applied to the term, 
-- resulting in an Tm with type lambdas at the right spots.
generalise :: TyEnv -> Ty -> TyScheme
generalise env tau = let free = fv tau DS.\\ fv env
                     in  DS.fold Forall (Ty tau) free

-- | This gives us unique variable numbers, incrementing the seed each time.
-- Automatically invoked by AG system when the keyword 'UNIQUEREF' is used next 
-- to an attribute.
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- | Look up a variable's type in the given environment.
getVar :: Var -> TyEnv -> TyScheme
getVar x env =
  case DM.lookup x env of
    Just scheme -> scheme
    _           -> error ("This shouldn't happen. " ++ x ++
                          " wasn't found in the environment.")

annVar :: Int -> SAnn
annVar = AnnVar . ("b" ++) . show 

annPoint :: Int -> SAnn
annPoint = AnnPoint

emptyConstraint :: Set Constraint
emptyConstraint = DS.empty

(<:) :: SAnn -> SAnn -> Constraint
var@(AnnVar _) <: p@(AnnPoint _) = Constraint var p
_ <: _ = error "invalid constraint"

dot :: SimpleSubstitution -> SimpleSubstitution -> SimpleSubstitution
dot = Dot

dotApply :: Substitutable t => SimpleSubstitution -> t -> t
dotApply (Dot s1 s2) t = applySubst s1 (applySubst s2 t)
dotApply _           _ = error "not allowed"

-- | The unification algorithm. If none of the cases match, fail.
unify :: Ty -> Ty -> SimpleSubstitution

unify Nat Nat   = Identity
unify Bool Bool = Identity

unify (List t _) (List t' _) = unify t t'

unify t1@(TyVar tv1) t2@(TyVar tv2) | tv1 == tv2 = Identity
                                    | tv1 `DS.notMember` fv t2 = TySub tv1 t2
                                    | tv2 `DS.notMember` fv t1 = TySub tv2 t1
                                    | otherwise = error "Cannot unify. Error."

unify (TyVar tv1) t | tv1 `DS.notMember` fv t = TySub tv1 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv1 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify t (TyVar tv2) | tv2 `DS.notMember` fv t = TySub tv2 t
                    | otherwise = error $ "Occurs check: " ++
                                            show tv2 ++ " = " ++
                                            show t
                                            ++ "\nCannot create infinite type."

unify (Arr t11 t12 an1) (Arr t21 t22 an2) =
  let theta0 = AnnSub an2 an1
      theta1 = unify (applySubst theta0 t11) (applySubst theta0 t21)
      theta2 = unify (applySubst (theta1 `dot` theta0) t12) (applySubst (theta1 `dot` theta0) t22)
  in theta2 `dot` theta1 `dot` theta0

unify t1 t2 = error $ "Unification failure. \nt_1 = " ++
                      show t1 ++ "\nt_2 = " ++
                      show t2

-- | A Type environment maps variable names to types.
type TyEnv = Map Var TyScheme

type Constraints = DS.Set Constraint

data Constraint = Constraint SAnn SAnn
  deriving (Show,Ord,Eq)

data SimpleSubstitution = Identity
                        | TySub TyVar Ty
                        | AnnSub SAnn SAnn
                        | Dot SimpleSubstitution SimpleSubstitution

class FreeVariables a where
    fv :: a -> Set String

class Substitutable subject where
  applySubst :: SimpleSubstitution -> subject -> subject


instance Show SimpleSubstitution where
  show Identity = ""
  show (TySub v t) = v ++ " |-> " ++ show t
  show (AnnSub a a') = show a ++ " |-> " ++ show a'
  show (Dot s s') = show s ++ ", " ++ show s'

instance Substitutable TyScheme where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t

  applySubst s@(TySub a _) (Forall tv ts) | a == tv   = Forall tv ts
                                          | otherwise = Forall tv (applySubst s ts)
  applySubst sub (Ty t) = Ty $ applySubst sub t
  
instance Substitutable Ty where
  applySubst Identity     t = t
  applySubst (AnnSub _ _) t = t
  applySubst d@(Dot _ _)  t = dotApply d t

  applySubst (TySub a t0) (TyVar t) 
    | a == t    = t0
    | otherwise = TyVar t

  applySubst s (Arr t1 t2 ann) = Arr (applySubst s t1) (applySubst s t2) (applySubst s ann)

  applySubst s (List t ann) = List (applySubst s t) (applySubst s ann)

  applySubst _ Nat  = Nat
  applySubst _ Bool = Bool
  
instance Substitutable TyEnv where
  applySubst s = DM.map (applySubst s)

instance Substitutable Constraints where
  applySubst s = DS.map (applySubst s)

instance Substitutable Constraint where
  applySubst Identity    subj = subj
  applySubst d@(Dot _ _) subj = dotApply d subj

  applySubst s (Constraint b pi) = Constraint (applySubst s b) (applySubst s pi)

instance Substitutable SAnn where
  applySubst Identity    a = a
  applySubst d@(Dot _ _) a = dotApply d a

  applySubst (AnnSub (AnnVar b) (AnnVar b')) a@(AnnVar b'') 
    | b == b''  = AnnVar b'
    | otherwise = a

  applySubst _ a = a

instance FreeVariables TyScheme where
  fv (Forall v s)  = fv s DS.\\ DS.singleton v
  fv (Ty t)        = fv t

instance FreeVariables Ty where
  fv (TyVar tv)                  = DS.singleton tv
  fv (Arr t1 t2 ann)             = fv t1 `DS.union` fv t2
  fv Nat                         = DS.empty
  fv Bool                        = DS.empty
  fv (List t1 _)                 = fv t1
  
instance FreeVariables TyEnv where
  fv = DM.fold (\el acc -> fv el `DS.union` acc) DS.empty

{- absWl constr bottom join atMost eval = iterAbsWl workLst ana infl join atMost eval-}
{-   where workLst = constr-}
{-         ana     = DM.fromList [(x, bottom)   | Constraint x _ <- constr]-}
{-         infl'   = DM.fromList [(x, DS.empty) | Constraint x _ <- constr]-}
{-         infl    = let inflx' k = DM.fromMaybe DS.empty (DM.lookup k infl')-}
{-                   in  DM.fromList [ (x, cs)-}
{-                                   | cxt@(Constraint x t) <- constr-}
{-                                   , cs <- [ inflx' x' `DS.union` DS.singleton cxt-}
{-                                           | x' <- DS.toList $ fv t]]-}

{- iterAbsWl []                    ana _      _    atMost eval = ana-}
{- iterAbsWl (Constraint x t:wltl) ana inflow join atMost eval-}
{-   | not $ atMost (anaLU x) new = iterAbsWl newWl ana' inflow join atMost eval-}
{-   | otherwise                  = iterAbsWl wltl  ana  inflow join atMost eval-}
{-   where new     = eval t ana-}
{-         ana'    = ana `join` new-}
{-         newWl   = wltl ++ (DM.fold (\c xs -> DS.toList c ++ xs) [] inflow) -- TODO: Double check-}
{-         anaLU x = DM.fromJust $ DM.lookup x ana-}
}
